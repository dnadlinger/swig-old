Version 1.3.22 (in progress)
==================================

04/07/2004: cheetah (William Fulton)
            [C#] C++ enums are no longer wrapped by integers, they are now wrapped by 
            C# enums. For Example, given C++:

                enum AnEnum { foo, bar };
                typedef AnEnum AnEnumeration;
                void something(AnEnum e, AnEnumeration f);

            The following is generated:

                public enum AnEnum {
                  foo,
                  bar
                }
                public static void something(AnEnum e, AnEnum f) {...}

            Note that a global enum like AnEnum above is generated into its own
            file called AnEnum.cs. Enums defined within a C++ class are defined
            within the C# proxy class. Some of the typemaps for modifying C# proxy
            classes also work for enums. For example global enums can use

                %typemap(csimports) to add in extra using statements.

            Global enums and class enums can use

                %typemap(csclassmodifiers) to make the enum private, public etc.
                %typemap(csbase) to change the underlying enum type (enum base)

            If we add this for the above example:

                %typemap(csclassmodifiers) AnEnum "protected"
                %typemap(csbase) AnEnum "long"

            the following is generated:
            
                protected enum AnEnum : long {
                  foo,
                  bar
                }

            *** POTENTIAL INCOMPATIBILITY FOR C# MODULE ***

            The original behaviour where constant integers are generated for each enum value
            can be achieved by using the %csenumint(flag) feature. For example,

                %csenumint(1);

            for all enums. Or 

                %csenumint(1) AnEnum;

            which for the example above will generate:

                public static void something(int e, int f) { ... }
                public const int foo = 0;
                public const int bar = foo + 1;

04/07/2004: cheetah (William Fulton)
            Seg fault fix for empty enums, like
                enum Foo {};

03/21/2004: mmatus
	    [Python] Makes the following 'var' cases more uniform:

                std::string ga;
 
                struct A {
                  static std::string sa;
                  std::string ma;
                };


            now the three variables (ga, sa, ma) can be assigned as:


                  cvar.ga = "hello";
                  A.sa = "hello";
                  a.ma = "hello";

            ie, now 'ma' will also use a std::string typemap 'in' if
            defined, before it was only accepting a 'p_std_string'
            pointer.  Note, however, that 'ma' will not use the
            'varin/varout' typemaps (that probably could be more
            natural), but it will pick up the 'in' typemap for const
            std::string& (which is easier).

	    The changes in cwrap.c and lang.cxx will probably fix the
	    behaviour in other languages that do not overload the
	    membervarHandler method "too much".
 
            
03/21/2004: mmatus
	    [Python] Disabling the default instantiations like:

	      %template() std::pair<int,int>;

            for all the primitive types and STL containers/classes.
	    They are expensive, specially for pair and map, and the
	    previous behaviour also requires the user to perform
	    manual instantiations. Still, if the speed difference is
	    not important, it can be re-enabled by defining the macro
	    SWIG_STD_DEFAULT_INSTANTIATION (see std_common.i).

	    Also, normalizing the INPUT/OUTPUT/INOUT typemaps. Now
	    they use the same conversors than the rest of the
	    typemaps, and you can use them for std::pair, std::string
	    and all the other STL types, like in:

	      void p_inoutd(std::pair<double, double> *INOUT);

	    Added the attribute.i and implicit.i files with macros to
	    transform functions pairs like 'set_x'/'get_x' 
	    (or 'T& x()'/'const T& x() const') into an attribute,
	    and allowing the use of implicit constructors in typemaps
	    (see the files for more details).

03/21/2004: mkoeppe
	    [Guile] Fix the documentation strings of functions with
	    anonymous arguments.

03/18/2004: mmatus
	    [Python] More general std_string.i interface.
	    Now you can wrap it using

	      %template(string) std::basic_string<char>;

            and use the std::string as a base class:

	      struct A : std::string {
              };

	    But more important, swig will recognize 
	    both std::basic_string<char> and std::string as
	    the same type.

03/16/2004: mmatus
	    Previously added, but not mentioned before:

	    - friend declaration support, swig now emits a global
	      function in the same class scope.

	    - ref/unref features: to mix ref counting C++ classes
	      and native script ref counting mechanisms (like in python).
	    
	      Use it like:

 	        %feature("ref")   RCObj "$this->ref();"
                %feature("unref") RCObj "$this->unref();"

	      And the class RCObj, and all the derived ones, will
	      perform the right ref/unref calls when a new pointer  
	      is returned to the target language, or when the target
	      language attempts to delete the object.
	      
	      See the refcount.i file in the test-suite for more
	      details.

	    
03/16/2004: mmatus
	    [Python] Using the new %fragment support, major rewrote 
	    of the python swig library, including:

	    - Almost automatic template/typemap instantiation for
	      the STL components. For example, now you can write:

		   %template(vector_i) std::vector<int>;

              and a specialized vector_i class is emitted with all
	      the needed typemaps. No need to use the old
	      'specialize_vector' macros.

	      Note you can also define

	          %template(matrix_i)   std::vector<std::vector<int> >;
	          %template(vector_pii) std::vector<std::pair<int,int> >;

	    - The empty template instantiation 
 	 
           	  %template() std::vector<int>;

	      defines the vector typemaps, but no proxy class. For all the
              fundamental types, the empty template instantiation are
              defined, so, you can say

	      %include std_vector

	      int func(const std::vector<int>& a);
	      
	      where the proper typemap is applied to 'a', but no
	      std::vector<int> proxy is generated.
	      

            - All the STL containers present a more uniform behavior and
	      more complete interface declaration. The following are 
	      now supported:

		  std::vector<T>
		  std::list<T>
		  std::deque<T>
		  std::set<T>
		  std::multiset<T>
		  std::map<T>
		  std::multimap<T>
              
              not a container, but also supported:

		  std::pair<T,U>

              also, more typemaps are defined for all of them,
	      including varin, varout, typecheck, etc.

            - Initial attempt to implement the STL containers
              considering allocators, ie:

	          std::vector<T,A>			

	      it is partially working, but it is just a workaround
	      while swig improves its template type support.
	      
	      
	     Please test with your particular setup. It seems to be
	     working with g++ 3.2.2, g++ 2.96, Intel icc and SGI CC
	     compilers, plus python 1.5.2, 2.0 and 2.3, but since
	     we are using templates, there is a chance you can find
	     some problems when using with an old C++ compiler.

03/16/2004: mmatus

            - Allowing the empty %template directive, such as

                 %template() std::vector<int>;

	      to process the class "typedef"s and "typemap"s. Before
	      only the internal "typedef"s were processed.

              This makes possible to emit the default in/out
              typemaps without the need of wrapping an specialized
              vector instance.

	    - Adding the preprocessor extension #@ which mangles the
              following macro argument, like in:

                #define macro(X)  #@X
                macro(int)         -> int
                macro(std::string) -> std_s_s_string
                
	    - Fragments can now be "type specialized", as the typemaps. The
	      syntax is as follows
 
                %fragment("name","header") 
                  { /* a type independent fragment (old syntax) */ }
                %fragment("name" {Type}, "header") 
                  { /* the fragment is type dependent */}
 
              Now fragments can also be used inside templates: 

                template <class T>
                struct A {
                   %fragment("incode"{A<T>},"header") {
		      /* 'incode' specialized fragment */
		   }
 
		   %typemap(in,fragment="incode"{A<T>}) {
		      /*
		         here we use the 'type specialized' 
                         fragment "incode"{A<T>}
                      */
		    }
                };
			     	

03/11/2004: cheetah (William Fulton)
            [Java] Director bug which meant that some virtual functions overridden in
            Java were not being called on some operating systems. Bug reported and fixed
            by Robert de Vries and Scott Michel.

03/02/2004: mkoeppe (Matthias Koeppe)
	    [Guile] In -scm mode, don't forget to check the type of string arguments.

02/24/2004: cheetah (William Fulton)
            [C#] New commandline option -namespace <name>. This allows one to specify
            a C# namespace into which all C# classes are generated.

02/23/2004: mkoeppe (Matthias Koeppe) 
	    [MzScheme] Use FUNC_NAME rather than a bogus typemap variable for signalling
	    errors.  Call scheme_wrong_type with a zero-based argument number.  
	    Reported by Ondrej Pacovsky, SF #902621.

	    [Guile] Define FUNC_NAME also in the dispatch wrapper for overloaded
	    functions.  Patch by John Lenz, SF #896255.

02/22/2004: mkoeppe (Matthias Koeppe)
	    [Guile] In -scm mode, don't try to invoke a null destructor function.

02/20/2004: cheetah (William Fulton)
            Fixes so that the SWIG source will compile using the Digital Mars Compiler
            (formerly Symantic compiler) on Windows. Submitted by Scott Michel.

02/13/2004: mkoeppe (Matthias Koeppe)
	    [MzScheme] New command-line argument -noinit.  Use it for building
	    the runtime library, where we don't want to define the functions
	    scheme_initialize etc.  Reported by Tim Brown, SF #891754.

	    [MzScheme] Don't produce invalid C code when invoked with the
	    -declaremodule option.  Reported by Tim Brown, SF #891108.
	    
	    [Guile] Build the runtime library with passive linkage, to rename
	    the SWIG_init function uniquely.

02/12/2004: cheetah (William Fulton)
            [Java, C#] Patch submitted by Bill Hoffman which prevents SWIG from crashing
            when a file for the typewrapper class cannot be opened.

02/11/2004: cheetah (William Fulton)
            [Java, C#] Overloading changes:
              - Methods which are overloaded in const only no longer generate Java
                code that won't compile - the first method parsed is used and a
                warning is displayed. Note that this behaviour is slightly different
                to the scripting languages which always uses the non-const method.
              - Warning messages 509 and 512 replaced by new warning number 516, which 
                is more relevant to these statically typed languages as the overloaded
                methods aren't 'shadowed', they are ignored.

01/23/2004: mkoeppe (Matthias Koeppe)
	    [Guile] Replace the "known_classes" hash table by a node
	    attribute.  Methods of classes in C++ namespaces now get
	    the proper specializer in the GOOPS declaration.
	    Reported by rm@mh-freiburg.de.

01/23/2004: mkoeppe (Matthias Koeppe)
	    [Guile] Uniquify the argument names in GOOPS shadow method
	    declarations.  Reported by rm@mh-freiburg.de.

01/21/2004: sunshine (Eric Sunshine)
            Revived the NextStep port of SWIG.

            Fixed fatal problem in DohStrstr() caused by difference in strstr()
            implementation which made %apply become entirely dysfunctional.  On
            NextStep, strstr("foo","") evaluates to NULL; whereas, on modern
            platforms, it evaluates to "foo".  %apply relies extensively upon
            strstr("foo","") evaluating to non-NULL, therefore it failed
            catastrophically when faced with NextStep's strstr().

            Added `bool' check to configure.in since NextStep's C++ compiler
            does not supply this type.  swig.h now fakes up `bool' if needed.

            Worked around NextStep C++ compiler bug in which C++ code is
            disallowed inside extern "C" functions.  This problem affected all
            language modules, since they publish hook functions of the form:
                extern "C" Language *swig_foo(void) { return new FOO(); }
            Fixed by creating a C++ wrapper:
                static Language *new_swig_foo() { return new FOO(); }
                extern "C" Language *swig_foo(void) { return new_swig_foo(); }

            Ensured that Swig_copy_string() is used in place of strdup() since
            NextStep does not supply strdup().

            Fixed detection of Ruby library name and location in configure.in.
            Problem 1: Assumed that library always resided in Ruby's "archdir",
            which was correct for Ruby 1.6.x, but which is incorrect for Ruby
            1.8.x, in which case the library normally resides in Ruby's
            "libdir".  Problem 2: Assumed that the library could always be
            linked via "-l"+RUBY_INSTALL_NAME (where RUBY_INSTALL_NAME
            typically is "ruby"), however this failed for platforms, such as
            NextStep, which do not support shared libraries.  In this case, the
            static library name in 1.8.x is libruby-static.a, thus
            -lruby-static is required.  The new logic works correctly for
            static and shared libraries for 1.6.x and 1.8.x.

            Fixed detection of Perl CFLAGS in configure.in for NextStep.
            Detection code extracted CFLAGS from Perl's %Config hash but
            neglected to add a newline to the value before passing it through
            `sed'.  NextStep's ancient `sed' discards input which is not
            terminated with a newline, thus Perl CFLAGS always evaluated to the
            empty string.

01/16/2004: cheetah (William Fulton)
            Tidy up in the exception handling code that is generated when
            C++ exception specifications are wrapped with the throws typemap.
            This redundant code is no longer generated:

                catch(...) {
                    throw; 
                }

