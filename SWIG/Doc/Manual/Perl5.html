<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and Perl5</title>
</head>

<body bgcolor="#ffffff">
<a name="n1"></a><H1>17 SWIG and Perl5</H1>
<!-- INDEX -->
<ul>
<li><a href="#n2">Overview</a>
<li><a href="#n3">Preliminaries</a>
<ul>
<li><a href="#n4">Getting the right header files</a>
<li><a href="#n5">Compiling a dynamic module</a>
<li><a href="#n6">Building a dynamic module with MakeMaker</a>
<li><a href="#n7">Building a static version of Perl</a>
<li><a href="#n8">Using the module</a>
<li><a href="#n9">Compilation problems and compiling with C++</a>
<li><a href="#n10">Compiling for 64-bit platforms</a>
</ul>
<li><a href="#n11">Building Perl Extensions under Windows</a>
<ul>
<li><a href="#n12">Running SWIG from Developer Studio</a>
<li><a href="#n13">Using other compilers</a>
</ul>
<li><a href="#n14">The low-level interface</a>
<ul>
<li><a href="#n15">Functions</a>
<li><a href="#n16">Global variables</a>
<li><a href="#n17">Constants</a>
<li><a href="#n18">Pointers</a>
<li><a href="#n19">Structures</a>
<li><a href="#n20">C++ classes</a>
<li><a href="#n21">C++ classes and type-checking</a>
<li><a href="#n22">C++ overloaded functions</a>
<li><a href="#n23">Operators</a>
<li><a href="#n24">Modules and packages</a>
</ul>
<li><a href="#n25">Input and output parameters</a>
<li><a href="#n26">Exception handling </a>
<li><a href="#n27">Remapping datatypes with typemaps</a>
<ul>
<li><a href="#n28">A simple typemap example</a>
<li><a href="#n29">Perl5 typemaps</a>
<li><a href="#n30">Typemap variables</a>
<li><a href="#n31">Useful functions</a>
</ul>
<li><a href="#n32">Typemap Examples</a>
<ul>
<li><a href="#n33">Converting a Perl5 array to a char ** </a>
<li><a href="#n34">Return values </a>
<li><a href="#n35">Returning values from arguments</a>
<li><a href="#n36">Accessing array structure members</a>
<li><a href="#n37">Turning Perl references into C pointers</a>
<li><a href="#n38">Pointer handling</a>
</ul>
<li><a href="#n39">Proxy classes</a>
<ul>
<li><a href="#n40">Preliminaries</a>
<li><a href="#n41">Object Ownership</a>
<li><a href="#n42">Nested Objects</a>
<li><a href="#n43">Shadow Functions</a>
<li><a href="#n44">Inheritance</a>
</ul>
</ul>
<!-- INDEX -->



<b>Caution: This chapter is under repair!</b>

<p>
This chapter describes SWIG's support of Perl5. Although the Perl5
module is one of the earliest SWIG modules, it has continued to evolve
and has been improved greatly with the help of SWIG users. For the
best results, it is recommended that SWIG be used with Perl5.003 or
later. Earlier versions are problematic and SWIG generated extensions
may not compile or run correctly.<p>

<a name="n2"></a><H2>17.1 Overview</H2>


To build Perl extension modules, SWIG uses a layered approach.  At
the lowest level, simple procedural wrappers are generated for
functions, classes, methods, and other declarations in the input file.
Then, for structures and classes, an optional collection of Perl
proxy classes can be generated in order to provide a more natural object oriented Perl
interface. These proxy classes simply build upon the low-level interface.

<p>
In describing the Perl interface, this chapter begins by covering the
essentials. First, the problem of configuration, compiling,
and installing Perl modules is discussed.  Next, the low-level
procedural interface is presented.  Finally, proxy classes are
described.  Advanced customization features, typemaps, and other
options are found near the end of the chapter.

<a name="n3"></a><H2>17.2 Preliminaries</H2>


To build a Perl5 module, run Swig using the <tt>-perl</tt> option as
follows :<p>

<blockquote><pre>
swig -perl example.i

</pre></blockquote>

This produces two files. The first file, <tt>example_wrap.c</tt>
contains all of the C code needed to build a Perl5 module. The second
file, <tt>example.pm</tt> contains supporting Perl code needed to
properly load the module.

<p>
To build the module, you will need to compile the file
<tt>example_wrap.c</tt> and link it with the rest of your program.

<a name="n4"></a><H3>17.2.1 Getting the right header files</H3>


In order to compile, SWIG extensions need the following Perl5 header files :<p>

<blockquote><pre>
#include "Extern.h"
#include "perl.h"
#include "XSUB.h"
</pre></blockquote>

<p>
These are typically located in a directory like this<p>

<p>
<blockquote><pre>/usr/lib/perl5/5.00503/i386-linux/CORE
</pre></blockquote>
<p>
The SWIG configuration script automatically tries to locate this directory so
that it can compile examples.  However, if you need to find out where the directory is
loaded, an easy way to find out is to run Perl itself.

<blockquote>
<pre>
% perl -e 'use Config; print $Config{archlib};'
/usr/lib/perl5/5.00503/i386-linux
</pre>
</blockquote>

<a name="n5"></a><H3>17.2.2 Compiling a dynamic module</H3>


The preferred approach to building an extension module is to compile it into
a shared object file or DLL.   To do this, you will need to compile your program
using comands like this (shown for Linux):

<blockquote><pre>$ swig -perl example.i
% gcc example.c
% gcc -c example_wrap.c -I/usr/lib/perl5/5.00503/i386-linux/CORE -Dbool=char
% gcc -shared example.o example_wrap.o -o example.so
</pre></blockquote>

The exact compiler options vary from platform to platform. 
SWIG tries to guess the right options when it is installed.  Therefore, 
you may want to start with one of the examples in the <tt>SWIG/Examples/perl5</tt> 
directory.   If that doesn't work, you will need to read the man-pages for
your compiler and linker to get the right set of options.  You might also
check the <a href="http://swig.cs.uchicago.edu/cgi-bin/wiki.pl">SWIG Wiki</a> for
additional information.

<p>
When linking the module, the name of the shared object file must match the module name used in
the SWIG interface file. If you used `<tt>%module example</tt>', then
the target should be named `<tt>example.so</tt>',
`<tt>example.sl</tt>', or the appropriate dynamic module name on your system.

<a name="n6"></a><H3>17.2.3 Building a dynamic module with MakeMaker</H3>


It is also possible to use Perl to build dynamically loadable modules
for you using the MakeMaker utility.  To do this, write a Perl
script such as the following :<p>

<p>
<blockquote><pre># File : Makefile.PL
use ExtUtils::MakeMaker;
WriteMakefile(
	`NAME'    =&gt; `example',                  # Name of package
	`LIBS'    =&gt; [`-lm'],                    # Name of custom libraries
	`OBJECT'  =&gt; `example.o example_wrap.o'  # Object files
);

</pre></blockquote>

Now, to build a module, simply follow these steps :<p>

<p>
<blockquote><pre>% perl Makefile.PL
% make
% make install
</pre></blockquote>

<p>
If you are planning to distribute a SWIG-generated module, this is
the preferred approach to compilation.  More information about MakeMaker can be
found in "Programming Perl, 2nd ed." by Larry Wall, Tom Christiansen,
and Randal Schwartz.<p>

<a name="n7"></a><H3>17.2.4 Building a static version of Perl</H3>


If you machine does not support dynamic loading or if you've tried to
use it without success, you can build a new version of the Perl
interpreter with your SWIG extensions added to it. To build a static
extension, you first need to invoke SWIG as follows :<p>

<p>
<blockquote><pre>% swig -perl -static example.i
</pre></blockquote>
<p>
By default SWIG includes code for dynamic loading, but the
<tt>-static</tt> option takes it out.<p>

<p>
Next, you will need to supply a <tt>main()</tt> function that
initializes your extension and starts the Perl interpreter. While,
this may sound daunting, SWIG can do this for you automatically as
follows :<p>

<blockquote><pre>
%module example

extern double My_variable;
extern int fact(int);

// Include code for rebuilding Perl
%include perlmain.i
</pre></blockquote>

<p>
The same thing can be accomplished by running SWIG as follows :<p>

<p>
<blockquote><pre>% swig -perl -static -lperlmain.i example.i

</pre></blockquote>

The <tt>permain.i</tt> file inserts Perl's <tt>main()</tt> function
into the wrapper code and automatically initializes the SWIG generated
module. If you just want to make a quick a dirty module, this may be
the easiest way. By default, the <tt>perlmain.i</tt> code does not
initialize any other Perl extensions. If you need to use other
packages, you will need to modify it appropriately. You can do this by
just copying <tt>perlmain.i</tt> out of the SWIG library, placing it
in your own directory, and modifying it to suit your purposes.<p>

<p>
To build your new Perl executable, follow the exact same procedure as
for a dynamic module, but change the link line to something like this:

<blockquote><pre>
% gcc example.o example_wrap.o -L/usr/lib/perl5/5.00503/i386-linux/CORE \
	-lperl -lsocket -lnsl -lm -o myperl
</pre></blockquote>

<p>
This will produce a new version of Perl called <tt>myperl</tt>. It
should be functionality identical to Perl with your C/C++ extension
added to it.  Depending on your machine, you may need to link with
additional libraries such as <tt>-lsocket, -lnsl, -ldl</tt>, etc.

<a name="n8"></a><H3>17.2.5 Using the module</H3>


To use the module, simply use the Perl <tt>use</tt> statement.  If
all goes well, you will be able to do this:

<p>
<blockquote><pre>$ perl
use example;
print example::fact(4),"\n";
24
</pre></blockquote>

A common error received by first-time users is the following:

<blockquote>
<pre>
use example;
Can't locate example.pm in @INC (@INC contains: /usr/lib/perl5/5.00503/i386-linux /usr/lib/perl5/5.00503 /usr/lib/perl5/site_perl/5.005/i386-linux /usr/lib/perl5/site_perl/5.005 .) at - line 1.
BEGIN failed--compilation aborted at - line 1.
</pre>
</blockquote>

This error is almost caused when the name of the shared object file you created doesn't match the module name
you specified with the <tt>%module</tt> directive.  

<p>
A somewhat related, but slightly different error is this:

<blockquote>
<pre>
use example;
Can't find 'boot_example' symbol in ./example.so
 at - line 1
BEGIN failed--compilation aborted at - line 1.
</pre>
</blockquote>

This error is generated because Perl can't locate the module bootstrap function in the
SWIG extension module.  This could be caused by a mismatch between the module name and the shared library name.
However, another possible cause is forgetting to link the SWIG-generated wrapper code with the rest
of your application when you linked the extension module.

<p>
Another common error is the following:

<blockquote>
<pre>
use example;
Can't load './example.so' for module example: ./example.so: 
undefined symbol: Foo at /usr/lib/perl5/5.00503/i386-linux/DynaLoader.pm line 169.

 at - line 1
BEGIN failed--compilation aborted at - line 1.
</pre>
</blockquote>

This error usually indicates that you forgot to include some object
files or libraries in the linking of the shared library file.  Make
sure you compile both the SWIG wrapper file and your original program
into a shared library file.  Make sure you pass all of the required libraries
to the linker.  

<p>
Sometimes unresolved symbols occur because a wrapper has been created
for a function that doesn't actually exist in a library.  This usually
occurs when a header file includes a declaration for a function that
was never actually implemented or it was removed from a library
without updating the header file.  To fix this, you can either edit
the SWIG input file to remove the offending declaration or you can use
the <tt>%ignore</tt> directive to ignore the declaration.  Better yet,
update the header file so that it doesn't have an undefined declaration.

<p>
Finally, suppose that your extension module is linked with another library like this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -o example.so
</pre>
</blockquote>

If the <tt>foo</tt> library is compiled as a shared library, you might get the following
error when you try to use your module:

<blockquote>
<pre>
use example;
Can't load './example.so' for module example: libfoo.so: cannot open shared object file: 
No such file or directory at /usr/lib/perl5/5.00503/i386-linux/DynaLoader.pm line 169.

 at - line 1
BEGIN failed--compilation aborted at - line 1.
>>>                 
</pre>
</blockquote>

This error is generated because the dynamic linker can't locate the
<tt>libfoo.so</tt> library.  When shared libraries are loaded, the
system normally only checks a few standard locations such as
<tt>/usr/lib</tt> and <tt>/usr/local/lib</tt>.   To get the loader to look in other
locations, there are several things you can do.  First, you can recompile your extension
module with extra path information. For example, on Linux you can do this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      <b>-Xlinker -rpath /home/beazley/projects/lib \</b>
      -o example.so
</pre>
</blockquote>

Alternatively, you can set the <tt>LD_LIBRARY_PATH</tt> environment
variable to include the directory with your shared libraries.  If
setting <tt>LD_LIBRARY_PATH</tt>, be aware that setting this variable
can introduce a noticeable performance impact on all other
applications that you run.  To set it only for Perl, you might want
to do this instead:

<blockquote>
<pre>
$ env LD_LIBRARY_PATH=/home/beazley/projects/lib perl
</pre>
</blockquote>

Finally, you can use a command such as <tt>ldconfig</tt> (Linux) or
<tt>crle</tt> (Solaris) to add additional search paths to the default
system configuration (this requires root access and you will need to
read the man pages).

<a name="n9"></a><H3>17.2.6 Compilation problems and compiling with C++</H3>


Compilation of C++ extensions has traditionally been a tricky problem.
Since the Perl interpreter is written in C, you need to take steps to
make sure C++ is properly initialized and that modules are compiled
correctly.

<p>
On most machines, C++ extension modules should be linked using the C++
compiler.  For example:

<p>
<blockquote><pre>% swig -c++ -perl example.i
% g++ -c example.cxx
% g++ -c example_wrap.cxx -I/usr/lib/perl5/5.00503/i386-linux/CORE
% <b>g++ -shared example.o example_wrap.o -o example.so</b>
</pre></blockquote>

In addition to this, you may need to include additional library
files to make it work.  For example, if you are using the Sun C++ compiler on
Solaris, you often need to add an extra library <tt>-lCrun</tt> like this:

<p>
<blockquote><pre>% swig -c++ -perl example.i
% g++ -c example.cxx
% g++ -c example_wrap.cxx -I/usr/lib/perl5/5.00503/i386-linux/CORE
% g++ -shared example.o example_wrap.o -o example.so <b>-lCrun</b>
</pre></blockquote>

Of course, the names of the extra libraries are completely non-portable---you will 
probably need to do some experimentation.

<p>
Another possible compile problem comes from recent versions of Perl (5.8.0) and the GNU tools.
If you see errors having to do with _crypt_struct, that means _GNU_SOURCE is not defined and
it needs to be.  So you should compile the wrapper like:

<blockquote><pre>
% g++ -c example_wrap.cxx -I/usr/lib/perl/5.8.0/CORE -D_GNU_SOURCE
</pre></blockquote>

-D_GNU_SOURCE is also included in the Perl ccflags, which can be found by running
<blockquote><pre>
% perl -e 'use Config; print $Config{ccflags};'
</pre></blockquote>
So you could also compile the wrapper like
<blockquote><pre>
% g++ -c example_wrap.cxx -I/usr/lib/perl/5.8.0/CORE `perl -e 'use Config; print $Config{ccflags}'`
</pre></blockquote>

<p>
Sometimes people have suggested that it is necessary to relink the
Perl interpreter using the C++ compiler to make C++ extension modules work.
In the experience of this author, this has never actually appeared to be
necessary on most platforms.   Relinking the interpreter with C++ really only includes the 
special run-time libraries described above---as long as you link your extension 
modules with these libraries, it should not be necessary to rebuild Perl.

<p>
If you aren't entirely sure about the linking of a C++ extension, you
might look at an existing C++ program.  On many Unix machines, the
<tt>ldd</tt> command will list library dependencies.  This should give
you some clues about what you might have to include when you link your
extension module. For example, notice the first line of output here:

<blockquote>
<pre>
$ ldd swig
        <b>libstdc++-libc6.1-1.so.2 => /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)</b>
        libm.so.6 => /lib/libm.so.6 (0x4005b000)
        libc.so.6 => /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
$
</pre>
</blockquote>

<p>
If linking wasn't enough of a problem, another major complication of C++ is that it does not
define any sort of standard for binary linking of libraries.  This
means that C++ code compiled by different compilers will not link
together properly as libraries nor is the memory layout of classes and
data structures implemented in any kind of portable manner.  In a
monolithic C++ program, this problem may be unnoticed.  However, in Perl, it
is possible for different extension modules to be compiled with
different C++ compilers.  As long as these modules are self-contained,
this probably won't matter.  However, if these modules start sharing data,
you will need to take steps to avoid segmentation faults and other
erratic program behavior.   Also, be aware that certain C++ features, especially RTTI,
can behave strangely when working with multiple modules.

<p>
It should be noted that you may get alot of error messages
about the `<tt>bool</tt>' datatype when compiling a C++ Perl module. If
you experience this problem, you can try the following :<p>

<p>
<ul>
<li>Use <tt>-DHAS_BOOL</tt> when compiling the SWIG wrapper code
<li>Or use <tt>-Dbool=char</tt> when compiling.
</ul>

<p>
Finally, recent versions of Perl (5.8.0) have namespace conflict problems.  Perl defines a bunch
of short macros to make the Perl API function names shorter.  For example, in 
/usr/lib/perl/5.8.0/CORE/embed.h there is a line:

<blockquote><pre>
#define do_open Perl_do_open
</pre></blockquote>

The problem is, in the &lt;iostream&gt; header from GNU libstdc++v3 there is a private 
function named do_open.  If &lt;iostream&gt; is included after the perl headers, then
the Perl macro causes the iostream do_open to be renamed, which causes compile errors.
Hopefully in the future Perl will support a PERL_NO_SHORT_NAMES flag, but for now the 
only solution is to undef the macros that conflict.  Lib/perl5/noembed.h in the SWIG 
source has a list of macros that are known to conflict with either standard headers or
other headers.  But if you get macro type conflicts from other macros not included
in Lib/perl5/noembed.h while compiling the wrapper, you will
have to find the macro that conflicts and add an #undef into the .i file.  Please report
any conflicting macros you find to <a href="mailto:swig@cs.uchicago.edu">swig@cs.uchicago.edu</a>.

<a name="n10"></a><H3>17.2.7 Compiling for 64-bit platforms</H3>


On platforms that support 64-bit applications (Solaris, Irix, etc.),
special care is required when building extension modules.  On these
machines, 64-bit applications are compiled and linked using a different
set of compiler/linker options.  In addition, it is not generally possible to mix 
32-bit and 64-bit code together in the same application.

<p>
To utilize 64-bits, the Perl executable will need to be recompiled
as a 64-bit application.  In addition, all libraries, wrapper code,
and every other part of your application will need to be compiled for
64-bits.  If you plan to use other third-party extension modules, they
will also have to be recompiled as 64-bit extensions.

<p>
If you are wrapping commercial software for which you have no source
code, you will be forced to use the same linking standard as used by
that software.  This may prevent the use of 64-bit extensions.  It may
also introduce problems on platforms that support more than one
linking standard (e.g., -o32 and -n32 on Irix).

<a name="n11"></a><H2>17.3 Building Perl Extensions under Windows</H2>


Building a SWIG extension to Perl under Windows is roughly
similar to the process used with Unix.  Normally, you will want to
produce a DLL that can be loaded into the Perl interpreter.  This
section assumes you are using SWIG with Microsoft Visual C++
although the procedure may be similar with other compilers.  

<a name="n12"></a><H3>17.3.1 Running SWIG from Developer Studio</H3>


If you are developing your application within Microsoft developer
studio, SWIG can be invoked as a custom build option.  The process
roughly requires these steps :<p>

<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL
project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer studio will keep a reference to it around.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -perl5 -o $(ProjDir)\$(InputName)_wrap.cxx
$(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>xx" in the "Output
files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Perl 5
installation under "Additional include directories".

<li>Define the symbols WIN32 and MSWIN32 under preprocessor options.
If using the ActiveWare port, also define the symbol PERL_OBJECT.
Note that all extensions to the ActiveWare port must be compiled with
the C++ compiler since Perl has been encapsulated in a C++ class.

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Perl library file to your link libraries.
For example "perl.lib".  Also, set the name of the output file to
match the name of your Perl module (ie. example.dll).

<li>Build your project.
</ul>
<p>
Now, assuming you made it this far, SWIG will be automatically invoked when
you build your project.  Any changes made to the interface file will
result in SWIG being automatically invoked to produce a new version of
the wrapper file.  To run your new Perl extension, simply run Perl and
use the use command as normal. For example :<p>
<p>
<blockquote><pre>
DOS &gt; perl
use example;
$a = example::fact(4);
print "$a\n";

</pre></blockquote>

<a name="n13"></a><H3>17.3.2 Using other compilers</H3>


SWIG is known to work with Cygwin and may work with other compilers on Windows.
For general hints and suggestions refer to the <a href="Windows.html">Windows</a> chapter.

<a name="n14"></a><H2>17.4 The low-level interface</H2>


At its core, the Perl module uses a simple low-level interface
to C function, variables, constants, and classes.  This low-level interface
can be used to control your application.  However, it is also used to
construct more user-friendly proxy classes as described in the next section.

<a name="n15"></a><H3>17.4.1 Functions</H3>


C functions are converted into new Perl built-in commands (or
subroutines). For example:

<p>
<blockquote><pre>%module example
int fact(int a);
...

</pre></blockquote>
Now, in Perl:
<p>
<blockquote><pre>use example;
$a = &amp;example::fact(2);
</pre></blockquote>

<a name="n16"></a><H3>17.4.2 Global variables</H3>


Global variables are handled using Perl's magic
variable mechanism.   SWIG generates a pair of functions
that intercept read/write operations and attaches them to a Perl variable with
the same name as the C global variable. Thus, an interface like this <p>

<p>
<blockquote><pre>%module example;
...
double Spam;
...

</pre></blockquote>
is accessed as follows :<p>

<p>
<blockquote><pre>use example;
print $example::Spam,"\n";
$example::Spam = $example::Spam + 4
# ... etc ...

</pre></blockquote>

<p>
If a variable is declared as <tt>const</tt>, it is wrapped as a
read-only variable.  Attempts to modify its value will result in an
error.

<p>
To make ordinary variables read-only, you can also use the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
%immutable;
extern char *path;
%mutable;
</pre>
</blockquote>

The <tt>%immutable</tt> directive stays in effect until it is explicitly disabled using
<tt>%mutable</tt>.  It is also possible to tag a specific variable as read-only like this:

<blockquote>
<pre>
%immutable path; 
...
...
extern char *path;       // Declared later in the input
</pre>
</blockquote>

<a name="n17"></a><H3>17.4.3 Constants</H3>


Constants are wrapped as read-only Perl variables.  For example:

<blockquote>
<pre>
%module example

#define FOO 42
</pre>
</blockquote>

In Perl:

<blockquote>
<pre>
use example;
print $example::FOO,"\n";    # OK
$example::FOO = 2;           # Error
</pre>
</blockquote>

<a name="n18"></a><H3>17.4.4 Pointers</H3>


SWIG represents pointers as blessed references.  A blessed reference
is the same as a Perl reference except that it has additional
information attached to it indicating what kind of reference it
is. That is, if you have a C declaration like this :<p>

<p>
<blockquote><pre>Matrix *new_Matrix(int n, int m);
</pre></blockquote>

<p>
The module returns a value generated as follows:

<blockquote><pre>
$ptr = new_Matrix(int n, int m);     # Save pointer return result
bless $ptr, "p_Matrix";              # Bless it as a pointer to Matrix
</pre></blockquote>

<p>
SWIG uses the "blessing" to check the datatype of various pointers.
In the event of a mismatch, an error or warning message is
generated.<p>

<p>
To check to see if a value is the NULL pointer, use the
<tt>defined()</tt> command :<p>

<blockquote><pre>
if (defined($ptr)) {
	print "Not a NULL pointer.";
} else {
	print "Is a NULL pointer.";
}

</pre></blockquote>

To create a NULL pointer, you should pass the <tt>undef </tt>value to
a function.  <p>

<p>
The "value" of a Perl reference is not the same as the underlying C
pointer that SWIG wrapper functions return.  Suppose that <tt>$a</tt>
and <tt>$b</tt> are two references that point to the same C object.
In general, <tt>$a</tt> and <tt>$b</tt> will be different--since they
are different references.  Thus, it is a mistake to check the equality
of <tt>$a </tt>and <tt>$b</tt> to check the equality of two C
pointers.  The correct method to check equality of C pointers is to
dereference them as follows :<p>

<p>
<blockquote><pre>if ($$a == $$b) {
	print "a and b point to the same thing in C";
} else {
	print "a and b point to different objects.";
}

</pre></blockquote>

As much as you might be inclined to modify a pointer value directly
from Perl, don't.  Manipulating pointer values is architecture dependent and
could cause your program to crash.  Similarly, don't try to manually cast
a pointer to a new type by reblessing a pointer.  This 
may not work like you expect and it is particularly dangerous when
casting C++ objects. If you need to cast a pointer or
change its value, consider writing some helper functions instead.  For
example:

<blockquote>
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</blockquote>

Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
<tt>NULL</tt> if the conversion can't be performed.

<P>
<b>Compatibility Note:</b> In earlier versions, SWIG tried to preserve the same pointer naming conventions
as XS and <tt>xsubpp</tt>.  Given the advancement of the SWIG typesystem and the growing differences between 
SWIG and XS, this is no longer supported.

<a name="n19"></a><H3>17.4.5 Structures</H3>


Access to the contents of a structure are provided through a set of low-level
accessor functions as described in the "SWIG Basics" chapter.  For example,
<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>

gets mapped into the following collection of accessor functions:

<p>
<blockquote><pre>
struct Vector *new_Vector();
void           delete_Vector(Vector *v);
double         Vector_x_get(Vector *obj)
void           Vector_x_set(Vector *obj, double x)
double         Vector_y_get(Vector *obj)
void           Vector_y_set(Vector *obj, double y)
double         Vector_z_get(Vector *obj)
void           Vector_z_set(Vector *obj, double z)

</pre></blockquote>

These functions are then used to access structure data from Perl as follows:

<p>
<blockquote><pre>
$v = example::new_Vector();
print example::Vector_x_get($v),"\n";    # Get x component
example::Vector_x_set($v,7.8);          # Change x component
</pre></blockquote>
<p>

Similar access is provided for unions and the data members of C++ classes.<p>

<p>
<tt>const</tt> members of a structure are read-only. Data members
can also be forced to be read-only using the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
struct Foo {
   ...
   %immutable;
   int x;        /* Read-only members */
   char *name;
   %mutable;
   ...
};
</pre>
</blockquote>

<p>
When <tt>char *</tt> members of a structure are wrapped, the contents are assumed to be
dynamically allocated using <tt>malloc</tt> or <tt>new</tt> (depending on whether or not
SWIG is run with the -c++ option).   When the structure member is set, the old contents will be 
released and a new value created.   If this is not the behavior you want, you will have to use
a typemap (described later).

<p>
Array members are normally wrapped as read-only.   For example,

<blockquote>
<pre>
struct Foo {
   int  x[50];
};
</pre>
</blockquote>

produces a single accessor function like this:

<blockquote>
<pre>
int *Foo_x_get(Foo *self) {
    return self->x;
};
</pre>
</blockquote>

If you want to set an array member, you will need to supply a "memberin" typemap
described later in this chapter.  As a special case, SWIG does generate
code to set array members of type <tt>char</tt> (allowing you to store a Python
string in the structure).

<p>
When structure members are wrapped, they are handled as pointers.   For example,

<blockquote>
<pre>
struct Foo {
   ...
};

struct Bar {
   Foo f;
};
</pre>
</blockquote>

generates accessor functions such as this:

<blockquote>
<pre>
Foo *Bar_f_get(Bar *b) {
    return &b->f;
}

void Bar_f_set(Bar *b, Foo *val) {
    b->f = *val;
}
</pre>
</blockquote>


<a name="n20"></a><H3>17.4.6 C++ classes</H3>


C++ classes are wrapped by building a set of low level accessor functions. 
Consider the following class :<p>

<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When wrapped by SWIG, the following functions are created :<p>

<p>
<blockquote><pre>List    *new_List();
void     delete_List(List *l);
int      List_search(List *l, char *item);
void     List_insert(List *l, char *item);
void     List_remove(List *l, char *item);
char    *List_get(List *l, int n);
int      List_length_get(List *l);
void     List_length_set(List *l, int n);
void     List_print(List *l);

</pre></blockquote>

In Perl, these functions are used in a straightforward manner:

<blockquote><pre>
use example;
$l = example::new_List();
example::List_insert($l,"Ale");
example::List_insert($l,"Stout");
example::List_insert($l,"Lager")
example::List_print($l)
Lager
Stout
Ale
print example::List_length_get($l),"\n";
3
</pre></blockquote>

At this low level, C++ objects are really just typed pointers.  Member
functions are accessed by calling a C-like wrapper with an instance pointer
as the first argument.   Although this interface is fairly primitive, it
provides direct access to C++ objects.  A higher level interface using Perl proxy classes
can be built using these low-level accessors.  This is described shortly.

<a name="n21"></a><H3>17.4.7 C++ classes and type-checking</H3>


The SWIG type-checker is fully aware of C++ inheritance.  Therefore, if you have
classes like this

<blockquote>
<pre>
class Foo {
...
};

class Bar : public Foo {
...
};
</pre>
</blockquote>

and a function

<blockquote>
<pre>
void spam(Foo *f);
</pre>
</blockquote>

then the function <tt>spam()</tt> accepts <tt>Foo *</tt> or a pointer to any class derived from <tt>Foo</tt>.
If necesssary, the type-checker also adjusts the value of the pointer (as is necessary when
multiple inheritance is used).

<a name="n22"></a><H3>17.4.8 C++ overloaded functions</H3>


If you have a C++ program with overloaded functions or methods, you will need to disambiguate
those methods using <tt>%rename</tt>.   For example:

<blockquote>
<pre>
/* Forward renaming declarations */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);
...
void foo(int);           // Becomes 'foo_i'
void foo(char *c);       // Stays 'foo' (not renamed)

class Spam {
public:
   void foo(int);      // Becomes 'foo_i'
   void foo(double);   // Becomes 'foo_d'
   ...
};
</pre>
</blockquote>

Now, in Perl, the methods are accessed as follows:

<blockquote>
<pre>
use example;
example::foo_i(3);
$s = example::new_Spam();
example::Spam_foo_i($s,3);
example::Spam_foo_d($s,3.14);
</pre>
</blockquote>

Please refer to the "SWIG Basics" chapter for more information. 

<a name="n23"></a><H3>17.4.9 Operators</H3>


C++ operators can also be wrapped using the <tt>%rename</tt> directive.  All you need to do is
give the operator the name of a valid Perl identifier.  For example:

<blockquote>
<pre>
%rename(add_complex) operator+(Complex &, Complex &);
...
Complex operator+(Complex &, Complex &);
</pre>
</blockquote>

Now, in Perl, you can do this:

<blockquote>
<pre>
use example;
$a = example::new_Complex(2,3);
$b = example::new_Complex(4,-1);
$c = example::add_complex($a,$b);
</pre>
</blockquote>

Some preliminary work on mapping C++ operators into Perl operators has been completed. This is covered later.

<a name="n24"></a><H3>17.4.10 Modules and packages</H3>


When you create a SWIG extension, everything gets placed into
a single Perl module. The name of the module is determined by the
<tt>%module</tt> directive. To use the module, do the following :<p>

<p>
<blockquote><pre>% perl5
use example;                      # load the example module
print example::fact(4),"\n"       # Call a function in it
24
</pre></blockquote>

<p>
Usually, a module consists of a collection of code that is contained
within a single file. A package, on the other hand, is the Perl
equivalent of a namespace. A package is alot like a module, except
that it is independent of files. Any number of files may be part of
the same package--or a package may be broken up into a collection of
modules if you prefer to think about it in this way.<p>

<p> SWIG installs its functions into a package with the same name as
the module. </p>

<p><b>Incompatible Change:</b> previous versions of SWIG enabled you to
change the name of the package by using the -package option, this
feature has been removed in order to properly support modules that
used nested namespaces, e.g. Foo::Bar::Baz. To give your module a
nested namespace simply provide the fully qualified name in your
%module directive: </p>

<blockquote><pre>%module "Foo::Bar::Baz"
</pre></blockquote>

<p><b>NOTE:</b> the double quotes are necessary.

<!--
This can be changed by giving SWIG the -package
option :<p>

<p>
<blockquote><pre>% swig -perl -package Foo example.i
</pre></blockquote>

<p>
In this case, you still create a module called `<tt>example</tt>' exactly as before, but
all of the functions in that module will be installed into the package
`<tt>Foo</tt>.' For example :<p>
<p>
<blockquote><pre>use example;   # Load the module like before
print Foo::fact(4),"\n";        # Call a function in package FooBar
</pre></blockquote>
-->

<a name="n25"></a><H2>17.5 Input and output parameters</H2>


A common problem in some C programs is handling parameters passed as simple pointers.  For
example:

<blockquote>
<pre>
void add(int x, int y, int *result) {
   *result = x + y;
}
</pre>
</blockquote>

or perhaps

<blockquote>
<pre>
int sub(int *x, int *y) {
   return *x+*y;
}
</pre>
</blockquote>

The easiest way to handle these situations is to use the <tt>typemaps.i</tt> file.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</pre>
</blockquote>

In Perl, this allows you to pass simple values.  For example:

<blockquote>
<pre>
$a = example::add(3,4);
print "$a\n";
7
$b = example::sub(7,4);
print "$b\n";
3
</pre>
</blockquote>

Notice how the <tt>INPUT</tt> parameters allow integer values to be passed instead of pointers
and how the <tt>OUTPUT</tt> parameter creates a return result.

<p>
If you don't want to use the names <tt>INPUT</tt> or <tt>OUTPUT</tt>, use the <tt>%apply</tt>
directive.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</pre>
</blockquote>

<p>
If a function mutates one of its parameters like this,

<blockquote>
<pre>
void negate(int *x) {
   *x = -(*x);
}
</pre>
</blockquote>

you can use <tt>INOUT</tt> like this:

<blockquote>
<pre>
%include "typemaps.i"
...
void negate(int *INOUT);
</pre>
</blockquote>

In Perl, a mutated parameter shows up as a return value.  For example:

<blockquote>
<pre>
$a = example::negate(3);
print "$a\n";
-3
</pre>
</blockquote>

<p>
The most common use of these special typemap rules is to handle functions that
return more than one value.   For example, sometimes a function returns a result
as well as a special error code:

<blockquote>
<pre>
/* send message, return number of bytes sent, along with success code */
int send_message(char *text, int len, int *success);
</pre>
</blockquote>

To wrap such a function, simply use the <tt>OUTPUT</tt> rule above. For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *success };
...
int send_message(char *text, int *success);
</pre>
</blockquote>

When used in Perl, the function will return multiple values.  

<blockquote>
<pre>
($bytes, $success) = example::send_message("Hello World");
</pre>
</blockquote>

Another common use of multiple return values are in query functions.  For example:

<blockquote>
<pre>
void get_dimensions(Matrix *m, int *rows, int *columns);
</pre>
</blockquote>

To wrap this, you might use the following:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *rows, int *columns };
...
void get_dimensions(Matrix *m, int *rows, *columns);
</pre>
</blockquote>

Now, in Perl:

<blockquote>
<pre>
($r,$c) = example::get_dimensions($m);
</pre>
</blockquote>

In certain cases, it is possible to treat Perl references as C pointers.  To do this, use the <tt>REFERENCE</tt> typemap.  For
example:

<blockquote>
<pre>
%module example
%include typemaps.i

void add(int x, int y, int *REFERENCE);
</pre>
</blockquote>

In Perl:

<blockquote>
<pre>
use example;
$c = 0.0;
example::add(3,4,\$c);
print "$c\n";
7
</pre>
</blockquote>

<b>Note:</b> The <tt>REFERENCE</tt> feature is only currently supported for numeric types (integers and floating point).

<a name="n26"></a><H2>17.6 Exception handling </H2>


The SWIG <tt>%exception</tt> directive can be used to create a
user-definable exception handler for converting exceptions in your
C/C++ program into Perl exceptions.  The chapter on customization features
contains more details, but suppose you have a C++ class like the
following :<p>

<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }

    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>

Since several methods in this class can throw an exception
for an out-of-bounds access, you might want to catch
this in the Perl extension by writing the following in an
interface file:

<p>
<blockquote><pre>%exception {
  try {
    $action
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}

class DoubleArray {
...
};
</pre></blockquote>

The exception handling code is inserted directly into generated wrapper
functions.  The <tt>$action</tt> variable is replaced with the C/C++
code being executed by the wrapper.  When an exception handler
is defined, errors can be caught and used to gracefully generate a Perl error
instead of forcing the entire program to terminate with an uncaught error.

<p>
As shown, the exception handling code will be added to every wrapper function.
Since this is somewhat inefficient.  You might consider refining the 
exception handler to only apply to specific methods like this:

<blockquote>
<pre>
%exception getitem {
  try {
    $action
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}

%exception setitem {
  try {
    $action
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}
</pre>
</blockquote>

In this case, the exception handler is only attached to methods and functions
named <tt>getitem</tt> and <tt>setitem</tt>.

<p>
If you had a lot of different methods, you can avoid extra typing by using a macro.
For example:

<blockquote>
<pre>
%define RANGE_ERROR
{
  try {
    $action
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}
%enddef

%exception getitem RANGE_ERROR;
%exception setitem RANGE_ERROR;
</pre>
</blockquote>

Since SWIG's exception handling is user-definable, you are not limited to C++ exception handling.
See the chapter on "<a href="Customization.html">Customization features</a>" for more examples.

<p>
<b>Compatibility note:</b> In SWIG1.1, exceptions were defined using the older <tt>%except</tt> directive:
<blockquote>
<pre>
%except(python) {
  try {
    $function
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}
</pre>
</blockquote>

This is still supported, but it is deprecated.  The newer <tt>%exception</tt> directive provides the same
functionality, but it has additional capabilities that make it more powerful.

<a name="n27"></a><H2>17.7 Remapping datatypes with typemaps</H2>


This section describes how you can modify SWIG's default wrapping behavior
for various C/C++ datatypes using the <tt>%typemap</tt> directive.   This
is an advanced topic that assumes familiarity with the Perl C API as well
as the material in the "<a href="Typemaps.html">Typemaps</a>" chapter.

<p>
Before proceeding, it should be stressed that typemaps are <em>not</em> a required 
part of using SWIG---the default wrapping behavior is enough in most cases.
Typemaps are only used if you want to change some aspect of the primitive
C-Perl interface.

<a name="n28"></a><H3>17.7.1 A simple typemap example</H3>


A typemap is nothing more than a code generation rule that is attached to 
a specific C datatype.   For example, to convert integers from Perl to C,
you might define a typemap like this:

<p>
<blockquote><pre>%module example

%typemap(in) int {
	$1 = (int) SvIV($input);
	printf("Received an integer : %d\n", $1);
}
...
extern int fact(int n);

</pre></blockquote>

<p>
Typemaps are always associated with some specific aspect of code generation.
In this case, the "in" method refers to the conversion of input arguments
to C/C++.  The datatype <tt>int</tt> is the datatype to which the typemap
will be applied.  The supplied C code is used to convert values.  In this
code a number of special variable prefaced by a <tt>$</tt> are used.  The
<tt>$1</tt> variable is placeholder for a local variable of type <tt>int</tt>.
The <tt>$input</tt> variable is the input object (usually a <tt>SV *</tt>).

<p>
When this example is used in Perl5, it will operate as follows :<p>

<p>
<blockquote><pre>use example;
$n = example::fact(6);
print "$n\n";
...

Output :
Received an integer : 6
720
</pre></blockquote>

<p>
The application of a typemap to specific datatypes and argument names involves
more than simple text-matching--typemaps are fully integrated into the
SWIG type-system.   When you define a typemap for <tt>int</tt>, that typemap
applies to <tt>int</tt> and qualified variations such as <tt>const int</tt>.  In addition,
the typemap system follows <tt>typedef</tt> declarations.  For example:

<blockquote>
<pre>
%typemap(in) int n {
	$1 = (int) SvIV($input);
	printf("n = %d\n",$1);
}
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
</pre>
</blockquote>

It should be noted that the matching of <tt>typedef</tt> only occurs in one direction.  If you
defined a typemap for <tt>Integer</tt>, it is not applied to arguments of
type <tt>int</tt>.

<p>
Typemaps can also be defined for groups of consecutive arguments.  For example:

<blockquote>
<pre>
%typemap(in) (char *str, unsigned len) {
    $1 = SvPV($input,$2);
};

int count(char c, char *str, unsigned len);
</pre>
</blockquote>

When a multi-argument typemap is defined, the arguments are always handled as a single
Perl object.  This allows the function to be used like this (notice how the length
parameter is ommitted):

<blockquote>
<pre>
example::count("e","Hello World");
1
>>>
</pre>
</blockquote>


<a name="n29"></a><H3>17.7.2 Perl5 typemaps</H3>


The previous section illustrated an "in" typemap for converting Perl objects to C.
A variety of different typemap methods are defined by the Perl module.  For example,
to convert a C integer back into a Perl object, you might define an "out" typemap
like this:


<blockquote>
<pre>
%typemap(out) int {
    $result = sv_newmortal();
    set_setiv($result, (IV) $1);
    argvi++;
}
</pre>
</blockquote>

The following typemap methods are available:
<p>
<tt>%typemap(in)</tt>
<blockquote>
Converts Perl5 object to input function arguments.<p>
</blockquote>

<p>
<tt>%typemap(out)</tt>
<blockquote>
Converts function return value to a Perl5 value.<p>
</blockquote>

<p>
<tt>%typemap(varin)</tt>
<blockquote>
Converts a Perl5 object to a global variable.<p>
</blockquote>

<p>
<tt>%typemap(varout)</tt>
<blockquote>
Converts a global variable to a Perl5 object.<p>
</blockquote>

<p>
<tt>%typemap(freearg)</tt>
<blockquote>
Cleans up a function argument after a function call<p>
</blockquote>

<p>
<tt>%typemap(argout)</tt>
<blockquote>
Output argument handling<p>
</blockquote>

<p>
<tt>%typemap(ret)        </tt>
<blockquote>
Clean up return value from a function.<p>
</blockquote>

<p>
<tt>%typemap(memberin)</tt>
<blockquote>
Setting of C++ member data (all languages).<p>
</blockquote>

<p>
<tt>%typemap(memberout)</tt>
<blockquote>
Return of C++ member data (all languages).<p>
</blockquote>

<p>
<tt>%typemap(check)</tt>
<blockquote>
Check value of input parameter.<p>
</blockquote>

<a name="n30"></a><H3>17.7.3 Typemap variables</H3>


Within typemap code, a number of special variables prefaced with a <tt>$</tt> may appear.
A full list of variables can be found in the "<a href="Typemaps.html">Typemaps</a>" chapter.
This is a list of the most common variables:

<p>
<tt>$1</tt>
<blockquote>
A C local variable corresponding to the actual type specified in the
<tt>%typemap</tt> directive.  For input values, this is a C local variable
that's supposed to hold an argument value.  For output values, this is
the raw result that's supposed to be returned to Perl.
</blockquote>

<p>
<tt>$input</tt>
<blockquote>
A Perl object holding the value of an argument of variable value.
</blockquote>

<p>
<tt>$result</tt>
<blockquote>
A Perl object that holds the result to be returned to Perl.
</blockquote>
<p>

<tt>$1_name</tt>
<blockquote>
The parameter name that was matched. 
</blockquote>
<p>

<tt>$1_type</tt>
<blockquote>
The actual C datatype matched by the typemap.
</blockquote>
<p>

<tt>$1_ltype</tt>
<blockquote>
An assignable version of the datatype matched by the typemap (a type that can appear on the left-hand-side of
a C assignment operation).  This type is stripped of qualifiers and may be an altered version of <tt>$1_type</tt>.
All arguments and local variables in wrapper functions are declared using this type so that their values can be
properly assigned.
</blockquote>

<tt>$symname</tt>
<blockquote>
The Perl name of the wrapper function being created.
</blockquote>

<a name="n31"></a><H3>17.7.4 Useful functions</H3>


When writing typemaps, it is necessary to work directly with Perl5
objects.  This, unfortunately, can be a daunting task.  Consult the
"perlguts" man-page for all of the really ugly details.  A short
summary of commonly used functions is provided here for reference.  It
should be stressed that SWIG can be usef quite effectively without
knowing any of these details--especially now that there are typemap
libraries that can already been written.<p>

<p>
<b>Perl Integer Functions</b>

<blockquote>
<pre>
int   SvIV(SV *);
void  sv_setiv(SV *sv, IV value);
SV   *newSViv(IV value);
int   SvIOK(SV *);
</pre>
</blockquote>

<b>Perl Floating Point Functions</b>

<blockquote>
<pre>
double SvNV(SV *);
void   sv_setnv(SV *, double value);
SV    *newSVnv(double value);
int    SvNOK(SV *);
</pre>
</blockquote>

<b>Perl String Functions</b>

<blockquote>
<pre>
char     *SvPV(SV *, STRLEN len);
void      sv_setpv(SV *, char *val);
void      sv_setpvn(SV *, char *val, STRLEN len);
SV       *newSVpv(char *value, STRLEN len);
int       SvPOK(SV *);
void      sv_catpv(SV *, char *);
void      sv_catpvn(SV *, char *, STRLEN);
</pre>
</blockquote>

<b>Perl References</b>

<blockquote>
<pre>
void      sv_setref_pv(SV *, char *, void *ptr);
int       sv_isobject(SV *);
SV       *SvRV(SV *);
int       sv_isa(SV *, char *0;
</pre>
</blockquote>


<a name="n32"></a><H2>17.8 Typemap Examples</H2>


This section includes a few examples of typemaps.  For more examples, you
might look at the files "<tt>perl5.swg</tt>" and "<tt>typemaps.i</tt>" in
the SWIG library.

<a name="n33"></a><H3>17.8.1 Converting a Perl5 array to a char ** </H3>


A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Perl5 array
reference to be used as a char ** datatype.<p>

<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
	AV *tempav;
	I32 len;
	int i;
	SV  **tv;
	if (!SvROK($input))
	    croak("Argument $argnum is not a reference.");
        if (SvTYPE(SvRV($input)) != SVt_PVAV)
	    croak("Argument $argnum is not an array.");
        tempav = (AV*)SvRV($input);
	len = av_len(tempav);
	$1 = (char **) malloc((len+2)*sizeof(char *));
	for (i = 0; i &lt;= len; i++) {
	    tv = av_fetch(tempav, i, 0);	
	    $1[i] = (char *) SvPV(*tv,PL_na);
        }
	$1[i] = NULL;
};

// This cleans up the char ** array after the function call
%typemap(freearg) char ** {
	free($1);
}

// Creates a new Perl array and places a NULL-terminated char ** into it
%typemap(out) char ** {
	AV *myav;
	SV **svs;
	int i = 0,len = 0;
	/* Figure out how many elements we have */
	while ($1[len])
	   len++;
	svs = (SV **) malloc(len*sizeof(SV *));
	for (i = 0; i &lt; len ; i++) {
	    svs[i] = sv_newmortal();
	    sv_setpv((SV*)svs[i],$1[i]);
	};
	myav =	av_make(len,svs);
	free(svs);
        $result = newRV((SV*)myav);
        sv_2mortal($result);
        argvi++;
}

// Now a few test functions
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}

// Returns a char ** list 
char **get_args() {
    static char *values[] = { "Dave", "Mike", "Susan", "John", "Michelle", 0};
    return &amp;values[0];
}
%}

</pre></blockquote>

When this module is compiled, the wrapped C functions can be used in a
Perl script as follows :<p>

<blockquote><pre>
use argv;
@a = ("Dave", "Mike", "John", "Mary");           # Create an array of strings
argv::print_args(\@a);                           # Pass it to our C function
$b = argv::get_args();                           # Get array of strings from C
print @$b,"\n";                                  # Print it out
</pre></blockquote>


<a name="n34"></a><H3>17.8.2 Return values </H3>


Return values are placed on the argument stack of each wrapper
function.  The current value of the argument stack pointer is
contained in a variable <tt>argvi</tt>.  Whenever a new output value
is added, it is critical that this value be incremented.  For multiple
output values, the final value of <tt>argvi</tt> should be the total
number of output values. <p>

<p>
The total number of return values should not exceed the number of
input values unless you explicitly extend the argument stack.  This
can be done using the <tt>EXTEND()</tt> macro as in :<p>

<p>
<blockquote><pre>%typemap(argout) int *OUTPUT {
	if (argvi &gt;= items) {            
		EXTEND(sp,1);              /* Extend the stack by 1 object */
	}
	$result = sv_newmortal();
	sv_setiv($target,(IV) *($1));
	argvi++;
}
</pre></blockquote>

<a name="n35"></a><H3>17.8.3 Returning values from arguments</H3>


Sometimes it is desirable for a function to return a value in one of
its arguments.  This example describes the implementation of the <tt>OUTPUT</tt> typemap.

<p>
<blockquote><pre>%module return

// This tells SWIG to treat an double * argument with name 'OutDouble' as
// an output value.  

%typemap(argout) double *OUTPUT {
	$result = sv_newmortal();
	sv_setnv($result, *$input);
	argvi++;                     /* Increment return count -- important! */
}

// We don't care what the input value is. Ignore, but set to a temporary variable

%typemap(in,numinputs=0) double *OUTPUT(double junk) {
	$1 = &amp;junk;
}

// Now a function to test it
%{
/* Returns the first two input arguments */
int multout(double a, double b, double *out1, double *out2) {
	*out1 = a;
	*out2 = b;
	return 0;
};
%}

// If we name both parameters OutDouble both will be output

int multout(double a, double b, double *OUTPUT, double *OUTPUT);
...
</pre></blockquote>

<p>
When this function is called, the output arguments are appended to the stack used
to return results.  This shows up an array in Perl.
For example :<p>

<p>
<blockquote><pre>@r = multout(7,13);
print "multout(7,13) = @r\n";
($x,$y) = multout(7,13);
</pre></blockquote>

<a name="n36"></a><H3>17.8.4 Accessing array structure members</H3>


Consider the following data structure :<p>
<p>
<blockquote><pre>#define SIZE  8
typedef struct {
    int   values[SIZE];
    ...
} Foo;

</pre></blockquote>

By default, SWIG doesn't know how to the handle the values structure
member it's an array, not a pointer.  In this case, SWIG makes the array member
read-only.   Reading will simply return a pointer to the first item in the array.
To make the member writable, a "memberin" typemap can be used.

<p>
<blockquote><pre>%typemap(memberin) int [SIZE] {
    int i;
    for (i = 0; i < SIZE; i++) {
        $1[i] = $input[i];
    }
}

</pre></blockquote>

Whenever a <tt>int [SIZE]</tt> member is encountered in a structure
or class, this typemap provides a safe mechanism for setting its
value.  

<p>
As in the previous example, the typemap can be generalized for any dimension.
For example:

<blockquote><pre>%typemap(memberin) int [ANY] {
   int i;
   for (i = 0; i < $1_dim0; i++) {
      $1[i] = $input[i];
   }
}
</pre></blockquote>

When setting structure members, the input object is always assumed to
be a C array of values that have already been converted from the
target language.  Because of this, the <tt>memberin</tt> typemap is
almost always combined with the use of an "in" typemap.  For example,
the "in" typemap in the previous section would be used to convert an
<tt>int[]</tt> array to C whereas the "memberin" typemap would be used
to copy the converted array into a C data structure.

<a name="n37"></a><H3>17.8.5 Turning Perl references into C pointers</H3>


A frequent confusion on the SWIG mailing list is errors caused by the
mixing of Perl references and C pointers.  For example, suppose you
have a C function that modifies its arguments like this :<p>

<p>
<blockquote><pre>void add(double a, double b, double *c) {
	*c = a + b;
}

</pre></blockquote>

A common misinterpretation of this function is the following Perl script :<p>

<p>
<blockquote><pre># Perl script
$a = 3.5;
$b = 7.5;
$c = 0.0;          # Output value
add($a,$b,\$c);    # Place result in c (Except that it doesn't work)
</pre></blockquote>

<p>
To make this work with a reference, you can use a typemap such as this:<p>

<p>
<blockquote><pre>%typemap(in) double * (double dvalue) {
  SV* tempsv;
  if (!SvROK($input)) {
    croak("expected a reference\n");
  }
  tempsv = SvRV($input);
  if ((!SvNOK(tempsv)) &amp;&amp; (!SvIOK(tempsv))) {
    croak("expected a double reference\n");
  }
  dvalue = SvNV(tempsv);
  $1 = &amp;dvalue;
}

%typemap(argout) double * {
  SV *tempsv;
  tempsv = SvRV($input);
  sv_setnv(tempsv, *$input);
}
</pre></blockquote>
<p>
Now, if you place this before the add function, you can do this :<p>
<p>
<blockquote><pre>$a = 3.5;
$b = 7.5;
$c = 0.0;
add($a,$b,\$c);            # Now it works!
print "$c\n";

</pre></blockquote>

<a name="n38"></a><H3>17.8.6 Pointer handling</H3>


Occasionally, it might be necessary to convert pointer values that have
been stored using the SWIG typed-pointer representation.  To convert a pointer from Perl to C, the following
function is used:

<p>
<tt>
int SWIG_ConvertPtr(SV *obj, void **ptr, swig_type_info *ty, int flags)
</tt>

<p>
<blockquote>
Converts a Perl object <tt>obj</tt> to a C pointer.  The result of the conversion is placed
into the pointer located at <tt>ptr</tt>.  <tt>ty</tt> is a SWIG type descriptor structure.
<tt>flags</tt> is used to handle error checking and other aspects of conversion. <tt>flags</tt> is
currently undefined and reserved for future expansion.  Returns 0 on success and -1 on error.
</blockquote>

<p>
<tt>
void *SWIG_MakePtr(SV *obj, void *ptr, swig_type_info *ty, int flags)</tt>
<p>

<blockquote>
Creates a new Perl pointer object.  <tt>obj</tt> is a Perl SV that has been initialized to hold the result,
<tt>ptr</tt is the pointer to convert, <tt>ty</tt> is the SWIG type descriptor structure that
describes the type, and <tt>flags</tt> is a flag that controls properties of the conversion.  <tt>flags</tt> is currently undefined
and reserved.

</blockquote>

Both of these functions require the use of a special SWIG
type-descriptor structure.  This structure contains information about
the mangled name of the datatype, type-equivalence information, as
well as information about converting pointer values under C++
inheritance.   For a type of <tt>Foo *</tt>, the type descriptor structure
is usually accessed as follows:

<blockquote>
<pre>
Foo *f;
if (SWIG_ConvertPtr($input, (void **) &f, SWIGTYPE_p_Foo, 0) == -1) return NULL;

SV *sv = sv_newmortal();
SWIG_MakePtr(sv, f, SWIGTYPE_p_Foo, 0);
</pre>
</blockquote>

In a typemap, the type descriptor should always be accessed using the special typemap
variable <tt>$1_descriptor</tt>.  For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr($input,(void **) &$1, $1_descriptor,0)) == -1) return NULL;
}
</pre>
</blockquote>

If necessary, the descriptor for any type can be obtained using the <tt>$descriptor()</tt> macro in a typemap.
For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr($input,(void **) &$1, $descriptor(Foo *), 0)) == -1) return NULL;
}
</pre>
</blockquote>

<a name="n39"></a><H2>17.9 Proxy classes</H2>


<b>Out of date. Needs update.</b>

<p>

Using the low-level procedural interface, SWIG can also construct a
high-level object oriented interface to C structures and C++ classes.
This is done by constructing a Perl proxy class that provides an OO wrapper
to the underlying code.  This section describes the implementation
details of the proxy interface.

<a name="n40"></a><H3>17.9.1 Preliminaries</H3>


To generate proxy classes, you need to use the <tt>-proxy</tt> command line option.
For example:

<blockquote>
<pre>
$ swig -c++ -perl -proxy example.i
</pre>
</blockquote>

When proxy classes are used, SWIG moves all of the low-level procedural wrappers to
another package name.  By default, this package is named 'modulec' where 'module' is the name of the module
you provided with the <tt>%module</tt> directive.  Then, in place of the original module, 
SWIG creates a collection of high-level Perl wrappers.  In your scripts, you will use these
high level wrappers.  The wrappers, in turn, interact with the low-level procedural module.

<h3>Structure and class wrappers</h2>

Suppose you have the following SWIG interface file :<p>

<p>
<blockquote><pre>%module example
struct Vector {
	Vector(double x, double y, double z);
	~Vector();
	double x,y,z;
};

</pre></blockquote>

When wrapped, SWIG creates the following set of low-level accessor
functions as described in previous sections.<p>

<p>
<blockquote><pre>Vector *new_Vector(double x, double y, double z);
void    delete_Vector(Vector *v);
double  Vector_x_get(Vector *v);
double  Vector_x_set(Vector *v, double value);
double  Vector_y_get(Vector *v);
double  Vector_y_set(Vector *v, double value);
double  Vector_z_get(Vector *v);
double  Vector_z_set(Vector *v, double value);

</pre></blockquote>

However, when proxy classes are enabled, these accessor functions are
wrapped inside a Perl class like this:

<p>
<blockquote><pre>package example::Vector;
@ISA = qw( example );
%OWNER = ();
%BLESSEDMEMBERS = ();

sub new () {
    my $self = shift;
    my @args = @_;
    $self = vectorc::new_Vector(@args);
    return undef if (!defined($self));
    bless $self, "example::Vector";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "example::Vector", $self;
    return bless \%retval,"Vector";
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
	 examplec::delete_Vector($self));
	 delete $OWNER{$self};
}

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "vectorc::Vector_${field}_get";
    my $val = &amp;$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "vectorc::Vector_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &amp;$member_func($self,tied(%{$newval}));
    } else {
        &amp;$member_func($self,$newval);
    }
}
</pre></blockquote>

<p>
Each structure or class is mapped into a Perl package of the same
name. The C++ constructors and destructors are mapped into
constructors and destructors for the package and are always named
"new" and "DESTROY".  The constructor always returns a tied hash
table.  This hash table is used to access the member variables of a
structure in addition to being able to invoke member functions.  The
<tt>%OWNER</tt> and <tt>%BLESSEDMEMBERS</tt> hash tables are used
internally and described shortly. <p>

<p>
To use our new shadow class we can simply do the following:<p>
<p>
<blockquote><pre># Perl code using Vector class
$v = new Vector(2,3,4);
$w = Vector-&gt;new(-1,-2,-3);

# Assignment of a single member
$v-&gt;{x} = 7.5;

# Assignment of all members
%$v = ( x=&gt;3,
	 y=&gt;9,
	 z=&gt;-2);

# Reading members
$x = $v-&gt;{x};

# Destruction
$v-&gt;DESTROY();

</pre></blockquote>

<a name="n41"></a><H3>17.9.2 Object Ownership</H3>


In order for shadow classes to work properly, it is necessary for Perl
to manage some mechanism of object ownership.  Here's the crux of the
problem---suppose you had a function like this :<p>
<p>
<blockquote><pre>Vector *Vector_get(Vector *v, int index) {
	return &amp;v[i];
}

</pre></blockquote>
This function takes a Vector pointer and returns a pointer to another
Vector.  Such a function might be used to manage arrays or lists of
vectors (in C).  Now contrast this function with the constructor for a
Vector object :<p>

<p>
<blockquote><pre>Vector *new_Vector(double x, double y, double z) {
	Vector *v;
	v = new Vector(x,y,z);        // Call C++ constructor
	return v;
}

</pre></blockquote>
Both functions return a Vector, but the constructor is returning a
brand-new Vector while the other function is returning a Vector that
was already created (hopefully).  In Perl, both vectors will be
indistinguishable---clearly a problem considering that we would
probably like the newly created Vector to be destroyed when we are
done with it.<p>

<p>
To manage these problems, each class contains two methods that access
an internal hash table called <tt>%OWNER</tt>.  This hash keeps a list
of all of the objects that Perl knows that it has created.  This
happens in two cases: (1) when the constructor has been called, and
(2) when a function implicitly creates a new object (as is done when
SWIG needs to return a complex datatype by value).  When the
destructor is invoked, the Perl shadow class module checks the
<tt>%OWNER</tt> hash to see if Perl created the object.  If so, the
C/C++ destructor is invoked.  If not, we simply destroy the Perl
object and leave the underlying C object alone (under the assumption
that someone else must have created it).<p>

<p>
This scheme works remarkably well in practice but it isn't foolproof.
In fact, it will fail if you create a new C object in Perl, pass it on
to a C function that remembers the object, and then destroy the
corresponding Perl object (this situation turns out to come up
frequently when constructing objects like linked lists and trees).
When C takes possession of an object, you can change Perl's owership
by simply deleting the object from the <tt>%OWNER</tt> hash.  This is
done using the <tt>DISOWN </tt>method.<p>

<p>
<blockquote><pre># Perl code to change ownership of an object
$v = new Vector(x,y,z);
$v-&gt;DISOWN();     
</pre></blockquote>
<p>
To acquire ownership of an object, the <tt>ACQUIRE</tt> method can be used.<p>
<p>
<blockquote><pre># Given Perl ownership of a file
$u = Vector_get($v);
$u-&gt;ACQUIRE();

</pre></blockquote>

As always, a little care is in order.  SWIG does not provide reference
counting, garbage collection, or advanced features one might find in
sophisticated languages.<p>

<a name="n42"></a><H3>17.9.3 Nested Objects</H3>


Suppose that we have a new object that looks like this :<p>
<p>
<blockquote><pre>struct Particle {
	Vector r;
	Vector v;
	Vector f;
	int	type;
}

</pre></blockquote>
In this case, the members of the structure are complex objects that
have already been encapsulated in a Perl shadow class.  To handle
these correctly, we use the <tt>%BLESSEDMEMBERS</tt> hash which would
look like this (along with some supporting code) :<p>

<p>
<blockquote><pre>package Particle;
...
%BLESSEDMEMBERS = (
	r =&gt; `Vector',
	v =&gt; `Vector',
	f =&gt; `Vector',
);

</pre></blockquote>

When fetching members from the structure, <tt>%BLESSEDMEMBERS</tt> is
checked.  If the requested field is present, we create a tied-hash
table and return it.  If not, we just return the corresponding member
unmodified.<p>

<p>
This implementation allows us to operate on nested structures as follows :<p>
<blockquote><pre>
# Perl access of nested structure
$p = new Particle();
$p-&gt;{f}-&gt;{x} = 0.0;
%${$p-&gt;{v}} = ( x=&gt;0, y=&gt;0, z=&gt;0);         
</pre></blockquote>
<p>
<a name="n43"></a><H3>17.9.4 Shadow Functions</H3>


When functions take arguments involving a complex object, it is
sometimes necessary to write a shadow function.  For example :<p>

<p>
<blockquote><pre>double dot_product(Vector *v1, Vector *v2);

</pre></blockquote>

Since Vector is an object already wrapped into a shadow class, we need
to modify this function to accept arguments that are given in the form
of tied hash tables.  This is done by creating a Perl function like
this :<p>

<p>
<blockquote><pre>sub dot_product {
    my @args = @_;
    $args[0] = tied(%{$args[0]});         # Get the real pointer values
    $args[1] = tied(%{$args[1]});
    my $result = vectorc::dot_product(@args);
    return $result;
}
</pre></blockquote>

<p>
This function replaces the original function, but operates in an
identical manner.<p>

<a name="n44"></a><H3>17.9.5 Inheritance</H3>


Simple C++ inheritance is handled using the Perl <tt>@ISA</tt> array
in each class package. For example, if you have the following
interface file :<p>

<p>
<blockquote><pre>// shapes.i
// SWIG interface file for shapes class
%module shapes
%{
#include "shapes.h"
%}

class Shape {
public:
	virtual double area() = 0;
	virtual double perimeter() = 0;
	void    set_location(double x, double y);
};
class Circle : public Shape {
public:
	Circle(double radius);
	~Circle();
	double area();
	double perimeter();
};
class Square : public Shape {
public:
	Square(double size);
	~Square();
	double area();
	double perimeter();
}

</pre></blockquote>

The resulting, Perl wrapper class will create the following code :<p>

<blockquote><pre>Package Shape;
@ISA = (shapes);
...
Package Circle;
@ISA = (shapes Shape);
...
Package Square;
@ISA = (shapes Shape);

</pre></blockquote>
The <tt>@ISA</tt> array determines where to look for methods of a
particular class.  In this case, both the <tt>Circle</tt> and
<tt>Square</tt> classes inherit functions from <tt>Shape</tt> so we'll
want to look in the <tt>Shape</tt> base class for them.  All classes
also inherit from the top-level module <tt>shapes</tt>.  This is
because certain common operations needed to implement shadow classes
are implemented only once and reused in the wrapper code for various
classes and structures.<p>

<p>
Since SWIG shadow classes are implemented in Perl, it is easy to
subclass from any SWIG generated class.  To do this, simply put the
name of a SWIG class in the <tt>@ISA</tt> array for your new
class. However, be forewarned that this is not a trivial problem.  In
particular, inheritance of data members is extremely tricky (and I'm
not even sure if it really works). <p>

<p><hr>

<address>SWIG 1.3 - Last Modified : Feb 13, 2003</address>
</body>
</html>