Version 1.3.41 (in progress)
============================

2009-11-02: olly
	    [Python] Fix potential memory leak in initialisation code for the
	    generated module.

2009-10-23: wsfulton
	    Fix seg fault when using a named nested template instantiation using %template(name) 
            within a class. A warning that these are not supported is now issued plus processing 
            continues as if no name was given.

2009-10-20: wsfulton
	    [Python] Fix std::vector<const T*>. This would previously compile, but not run correctly.

2009-10-20: wsfulton
	    Fixed previously fairly poor template partial specialization and explicit 
            specialization support. Numerous bugs in this area have been fixed including:

            - Template argument deduction implemented for template type arguments, eg this now
              works:
                template<typename T> class X      {};
                template<typename T> class X<T *> {};
                %template(X1) X<const int *>; // Chooses T * specialization

              and more complex cases with multiple parameters and a mix of template argument
              deduction and explicitly specialised parameters, eg:
                template <typename T1, typename T2> struct TwoParm               { void a() {} };
                template <typename T1>              struct TwoParm<T1 *, int *>  { void e() {} };
                %template(E) TwoParm<int **, int *>;

            Note that the primary template must now be in scope, like in C++, when
            an explicit or partial specialization is instantiated with %template.

            *** POTENTIAL INCOMPATIBILITY ***

2009-09-14: wsfulton
	    [C#] Add %csattributes for adding C# attributes to enum values, see docs for example.

2009-09-11: wsfulton
	    Fix memmove regression in cdata.i as reported by Adriaan Renting.

2009-09-07: wsfulton
	    Fix constant expressions containing <= or >=.

2009-09-02: wsfulton
	    The following operators in constant expressions now result in type bool for C++ 
            wrappers and remain as type int for C wrappers, as per each standard: 

              && || == != < > <= >= (Actually the last 4 are still broken). For example:

              #define A 10
              #define B 10
              #define A_EQ_B  A == B // now wrapped as type bool for C++
              #define A_AND_B A && B // now wrapped as type bool for C++

2009-09-02: wsfulton
	    Fix #2845746. true and false are now recognised keywords (only when wrapping C++).
            Constants such as the following are now wrapped (as type bool):
              #define FOO true
              #define BAR FOO && false

