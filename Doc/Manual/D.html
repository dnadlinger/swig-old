<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and D</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body bgcolor="#FFFFFF">
<H1><a name="D"></a>36 SWIG and D</H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#D_introduction">Introduction</a>
<li><a href="#D_command_line_invocation">Command line invocation</a>
<li><a href="#D_typemaps">Typemaps</a>
<ul>
<li><a href="#D_typemap_name_comparison">C# &lt;-&gt; D name comparison</a>
<li><a href="#D_cwtype_dwtype_dptype">cwtype, dwtype, dptype</a>
<li><a href="#D_in_out_directorin_direcetorout">in, out, directorin, directorout</a>
<li><a href="#D_din_dout_ddirectorin_ddirectorout">din, dout, ddirectorin, ddirectorout</a>
<li><a href="#D_typecheck_typemaps">typecheck typemaps</a>
<li><a href="#D_code_injection_typemaps">Code injection typemaps</a>
<li><a href="#D_special_variables">Special variable macros</a>
</ul>
<li><a href="#D_features">Features</a>
<li><a href="#D_pragmas">Pragmas</a>
<li><a href="#D_exceptions">D Exceptions</a>
<li><a href="#D_directors">D Directors</a>
<li><a href="#D_other_features">Other features</a>
<li><a href="#D_typemap_examples">D Typemap examples</a>
<li><a href="#D_planned_features">Work in progress and planned features</a>
</ul>
</div>
<!-- INDEX -->



<H2><a name="D_introduction"></a>36.1 Introduction</H2>


<H2><a name="D_command_line_invocation"></a>36.2 Command line invocation</H2>


<H2><a name="D_typemaps"></a>36.3 Typemaps</H2>


<H3><a name="D_typemap_name_comparison"></a>36.3.1 C# &lt;-&gt; D name comparison</H3>


<div class="diagram"><pre>
 ctype                  &lt;-&gt;  cwtype
 imtype                 &lt;-&gt;  dwtype
 cstype                 &lt;-&gt;  dptype
 csin                   &lt;-&gt;  din
 csout                  &lt;-&gt;  dout
 csdirectorin           &lt;-&gt;  ddirectorin
 csdirectorout          &lt;-&gt;  ddirectorout
 csinterfaces           &lt;-&gt;  dinterfaces
 csinterfaces_derived   &lt;-&gt;  dinterfaces_derived
 csbase                 &lt;-&gt;  dbase
 csclassmodifiers       &lt;-&gt;  dclassmodifiers
 cscode                 &lt;-&gt;  dcode
 csimports              &lt;-&gt;  dimports
 csbody                 &lt;-&gt;  dbody
 csfinalize             &lt;-&gt;  ddestructor
 csdestruct             &lt;-&gt;  ddispose
 csdestruct_derived     &lt;-&gt;  ddispose_derived
</pre></div>


<H3><a name="D_cwtype_dwtype_dptype"></a>36.3.2 cwtype, dwtype, dptype</H3>


<p>Mapping of types between the C/C++ library, the C/C++ library wrapper exposing the C functions, the D wrapper module importing these functions and the D proxy code.</p>

<p>The <tt>cwtype</tt> typemap is used to determine the types to use in the C wrapper functions. The types from the <tt>dwtype</tt> typemap are used in the extern(C) declarations of these functions in the D wrap module. The <tt>dptype</tt> typemap contains the D types used in the D proxy module/class.</p>


<H3><a name="D_in_out_directorin_direcetorout"></a>36.3.3 in, out, directorin, directorout</H3>


<p>Used for converting between the types for C/C++ and D when generating the code for the wrapper functions (on the C++ side).</p>

<p>The code from the <tt>in</tt> typemap is used to convert arguments to the C wrapper function to the type used in the wrapped code (<tt>cwtype</tt>->original C++ type), the <tt>out</tt> typemap is utilized to convert values from the wrapped code to wrapper function return types (original C++ type-><tt>cwtype</tt>).</p>

<p>The <tt>directorin</tt> typemap is used to convert parameters to the type used in the D director callback function, its return value is processed by <tt>directorout</tt> (see below).</p>


<H3><a name="D_din_dout_ddirectorin_ddirectorout"></a>36.3.4 din, dout, ddirectorin, ddirectorout</H3>


<p>Typemaps for code generation in D proxy and type wrapper classes.</p>

<p>The <tt>din</tt> typemap is used for converting function parameter types from the type used in the proxy module or class to the type used in the D wrap module (the <a href="D.html#D_dinput"><tt>$dinput</tt></a> macro is replaced).</p>

<p>The <tt>dout</tt> typemap is used for converting function return values from the return type used in the wrap D module to the type returned by the proxy function. The <tt>$excode</tt> special variable in <tt>dout</tt> typemaps is replaced by the <tt>excode</tt> typemap attribute code if the method can throw any exceptions from unmanaged code, otherwise by nothing (the <a href="D.html#D_wcall"><tt>$wcall</tt> and <tt>$owner</tt></a> macros are replaced).</p>

<p>The code from the <tt>ddirectorin</tt> and <tt>ddirectorout</tt> typemaps is used for conversion in director callback functions. Arguments are converted to the type used in the proxy class method they are calling by using the code from <tt>ddirectorin</tt>, the proxy class method return value is converted to the type the C++ code expects via the <tt>ddirectorout</tt> typemap.</p>

<p>The full chain of type conversions when a director callback is invoked looks like this:</p>

 <div class="diagram"><pre>      type CPPClass::method(type a)
        ↑                     ↓
   &lt;directorout&gt;         &lt;directorin&gt;
        ↑                     ↓
     cwtype methodCallback(ctype a)    C++
 ::::::::::::::::::::::::::::::::::::::::::
     dwtype methodCallback(dwtype a)    D
        ↑                     ↓
  &lt;ddirectorout&gt;       &lt;ddirectorin&gt;
        ↑                     ↓
      dptype DClass.method(dptype a)</pre></div>


<H3><a name="D_typecheck_typemaps"></a>36.3.5 typecheck typemaps</H3>


<p>Because, unlike many scripting languages supported by SWIG, D does not need any dynamic dispatch helper to access an overloaded function, the purpose of these is merely to issue a warning for overloaded C++ functions that cannot be overloaded in D (as more than one C++ type maps to a single D type).</p>


<H3><a name="D_code_injection_typemaps"></a>36.3.6 Code injection typemaps</H3>


<p>These typemaps are used for generating the skeleton of proxy classes for C++ types.</p>

<p>By overriding <tt>dbase</tt>, <tt>dinterfaces</tt> or <tt>dinterfaces_derived</tt>, the inheritance chain of the generated proxy class for a type can be modified. <tt>dclassmodifiers</tt> allows you to add any custom modifiers around the class keyword.</p>

<p>Using <tt>dcode</tt> and <tt>dimports</tt>, you can specify additional D code which will be emitted into the class body respectively the imports section of the D module the class is written to.</p>

<p><tt>dconstructor</tt>, <tt>ddestructor</tt>, <tt>ddispose</tt> and <tt>ddispose_derived</tt> are used to generate the class constructor, destructor and <tt>dispose()</tt> method, respectively. The auxiliary code for handling the pointer to the C++ object is stored in <tt>dbody</tt> and <tt>dbody_derived</tt>. You can override them for specific types.</p>


<H3><a name="D_special_variables"></a>36.3.7 Special variable macros</H3>


<p>The standard SWIG special variables are available for use within typemaps as described in the <a href="Typemaps.html#Typemaps">Typemaps documentation</a>, for example <tt>$1</tt>, <tt>$input</tt>, <tt>$result</tt> etc.</p>

<p>When generating D wrappers, a few additional macros are available:</p>
<dl>
  <dt><tt>$dclassname</tt> (C#: <tt>$csclassname</tt>)</dt>
  <dd>
    <p>This special variable works similar to <a href="Typemaps.html#Typemaps_special_variables"><tt>$n_type</tt></a> in that it returns the name of a type – it expands to the D proxy class name of the type being wrapped. If the type does not have an associated proxy class, it expands to the type wrapper class name, for example, <tt>SWIGTYPE_p_p_SomeCppClass</tt> is generated when wrapping <tt>SomeCppClass **</tt>.</p>
    <p>There are two other variants available, <tt>$&amp;dclassname</tt> and <tt>$*dclassname</tt>. The former adds a level of indirection, while the latter removes one. For instance, when wrapping <tt>Foo **</tt>, <tt>$*dclassname</tt> would be replaced by the proxy class name corresponding to <tt>Foo *</tt>.</p>
  </dd>

  <dt><tt>$null</tt></dt>
  <dd><p>In code inserted into the generated C/C++ wrapper functions, this variable is replaced by either <tt>0</tt> or nothing at all, depending on whether the function has a return value or not. It can be used to bail out early e.g. in case of errors (<tt>return $null;</tt>).</p></dd>

  <dt id="D_dinput"><tt>$dinput</tt></dt>
  <dd>
    <p>This variable is used in <tt>din</tt> typemaps and is replaced by the expression which is to be passed to C/C++.</p>
    <p>For example, this input</p>
    <div class="code"><pre>
%typemap(din) SomeClass * "SomeClass.getCPointer($dinput)"

%inline %{
  class SomeClass {};
  void foo(SomeClass *arg);
%}</pre></div>
    <p>leads to the following D proxy code being generated:</p>
<div class="targetlang"><pre>
void foo(SomeClass arg) {
  example_wrap.foo(SomeClass.getCPointer(arg));
}</pre></div></dd>

  <dt id="D_wcall"><tt>$wcall</tt> and <tt>$owner</tt> (C#: <tt>$imcall</tt>)</dt>
  <dd>
    <p>These variables are used in <tt>dout</tt> typemaps. <tt>$wcall</tt> contains the call to the wrapper layer which provides the value to be used, and <tt>$owner</tt> signals if the caller is responsible for managing the object lifetime (that is, if the called method is a constructor or has been marked via <tt>%newobject</tt>).</p>
    <p>Consider the following example:</p>
<div class="code"><pre>
%typemap(dout) SomeClass * {
  return new SomeClass($wcall, $owner);
}

%inline %{
  class SomeClass;
  SomeClass *foo();

  %newobject bar();
  SomeClass *bar();
%}</pre></div>
   <p>The code generated for <tt>foo()</tt> and <tt>bar()</tt> looks like this:</p>
<div class="targetlang"><pre>
SomeClass foo() {
  return new SomeClass(example_wrap.foo(), false);
}

SomeClass bar() {
  return new SomeClass(example_wrap.bar(), true);
}
</pre></div>
  </dd>
</dl>


<H2><a name="D_features"></a>36.4 Features</H2>


<H2><a name="D_pragmas"></a>36.5 Pragmas</H2>


<H2><a name="D_exceptions"></a>36.6 D Exceptions</H2>


<p>Out of the box, C++ exceptions are fundamentally incompatible to their equivalent in the D world and cannot simply be propagated to a calling D method. There is, however, an easy way to solve this problem: Just catch the exception in the C/C++ wrapper layer, pass the contents to D, and make the wrapper code rethrow the exception in the D world.</p>

<p>The implementation details of this are a bit crude, but the SWIG D module automatically takes care of this, as long as it is able to detect that an exception could potentially be thrown (e.g. because the C++ method has a <tt>throw()</tt> exception specification).</p>

<p>As this feature is implemented in exactly the same way it is for C#, please see the <a href="CSharp.html#CSharp_exceptions">C# documentation</a> for a more detailed explanation.</p>


<H2><a name="D_directors"></a>36.7 D Directors</H2>


<p>When the directors feature is activated, SWIG generates extra code on both the C++ and the D side to enable cross-language polymorphism. Essentially, this means that if you subclass a proxy class in D, C++ code can access any overridden virtual methods just as if you created a derived class in C++.</p>

<p>There is no D specific documentation yet, but the way the feature is implemented is very similar to how it is done in <a href="Java.html#Java_directors">Java</a> and <a href="CSharp.html#CSharp_directors">C#</a>.
</p>


<H2><a name="D_other_features"></a>36.8 Other features</H2>


<p>The <a href="SWIGPlus.html#SWIGPlus_nspace"><tt>nspace</tt></a> feature of SWIG is not yet supported for D – all class modules are written to the same package, regardless of which C++ namespace they are in.</p>



<H2><a name="D_typemap_examples"></a>36.9 D Typemap examples</H2>


<p>There are no D-specific typemap examples yet. However, with the above <a href="D.html#D_typemap_name_comparison">name comparison table</a>, you should be able to get an idea what can be done by looking at the <a href="CSharp.html#CSharp_typemap_examples">corresponding C# section</a>.</p>



<H2><a name="D_planned_features"></a>36.10 Work in progress and planned features</H2>


<p>There are a couple of features which are not implemented yet, but would be very useful and might be added in the near future:</p>

<ul>
  <li><em>Memory management:</em> Although the currently generated wrapper code works fine with regard to the GC for the test-suite, I would not be surprised if there are issues coming up in real-world multi-threaded usage.</li>
  <li><em>Static linking:</em> Currently, the C wrapper code is compiled into a dynamic library, out of which the symbol addresses are looked up at runtime by the D part. If statically linking the different languages into one binary was supported, a tool-chain capable of performing IPO at link time could inline the wrapping code, effectively reducing the overhead for simple calls to zero.</li>
  <li><em>C array handling:</em> Many data structures in some C/C++ libraries contain array containing of a pointer to the first element and the element count. Currently, one must manually writing wrapper code to be able to access these from D. It should be possible to add a set of SWIG macros to semi-automatically generate conversion code.</li>
</ul>


</body>
</html>

