<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and D</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<body bgcolor="#FFFFFF">
<H1><a name="D"></a>36 SWIG and D</H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#D_introduction">Introduction</a>
<li><a href="#D_command_line_invocation">Command line invocation</a>
<li><a href="#D_typemaps">Typemaps</a>
<ul>
<li><a href="#D_typemap_name_comparison">C# &lt;-&gt; D name comparison</a>
<li><a href="#D_cwtype_dwtype_dptype">cwtype, dwtype, dptype</a>
<li><a href="#D_in_out_directorin_direcetorout">in, out, directorin, directorout</a>
<li><a href="#D_din_dout_ddirectorin_ddirectorout">din, dout, ddirectorin, ddirectorout</a>
<li><a href="#D_typecheck_typemaps">typecheck typemaps</a>
<li><a href="#D_code_injection_typemaps">Code injection typemaps</a>
<li><a href="#D_special_variables">Special variable macros</a>
</ul>
<li><a href="#D_features">Features</a>
<li><a href="#D_pragmas">Pragmas</a>
<li><a href="#D_exceptions">D Exceptions</a>
<li><a href="#D_directors">D Directors</a>
<li><a href="#D_other_features">Other features</a>
<li><a href="#D_typemap_examples">D Typemap examples</a>
<li><a href="#D_planned_features">Work in progress and planned features</a>
</ul>
</div>
<!-- INDEX -->



<H2><a name="D_introduction"></a>36.1 Introduction</H2>


<H2><a name="D_command_line_invocation"></a>36.2 Command line invocation</H2>


<H2><a name="D_typemaps"></a>36.3 Typemaps</H2>


<H3><a name="D_typemap_name_comparison"></a>36.3.1 C# &lt;-&gt; D name comparison</H3>


<div class="diagram"><pre>
 ctype                  &lt;-&gt;  cwtype
 imtype                 &lt;-&gt;  dwtype
 cstype                 &lt;-&gt;  dptype
 csin                   &lt;-&gt;  din
 csout                  &lt;-&gt;  dout
 csdirectorin           &lt;-&gt;  ddirectorin
 csdirectorout          &lt;-&gt;  ddirectorout
 csinterfaces           &lt;-&gt;  dinterfaces
 csinterfaces_derived   &lt;-&gt;  dinterfaces_derived
 csbase                 &lt;-&gt;  dbase
 csclassmodifiers       &lt;-&gt;  dclassmodifiers
 cscode                 &lt;-&gt;  dcode
 csimports              &lt;-&gt;  dimports
 csbody                 &lt;-&gt;  dbody
 csfinalize             &lt;-&gt;  ddestructor
 csdestruct             &lt;-&gt;  ddispose
 csdestruct_derived     &lt;-&gt;  ddispose_derived
</pre></div>


<H3><a name="D_cwtype_dwtype_dptype"></a>36.3.2 cwtype, dwtype, dptype</H3>


<p>Mapping of types between the C/C++ library, the C/C++ library wrapper exposing the C functions, the D wrapper module importing these functions and the D proxy code.</p>

<p>The <tt>cwtype</tt> typemap is used to determine the types to use in the C wrapper functions. The types from the <tt>dwtype</tt> typemap are used in the extern(C) declarations of these functions in the D wrap module. The <tt>dptype</tt> typemap contains the D types used in the D proxy module/class.</p>


<H3><a name="D_in_out_directorin_direcetorout"></a>36.3.3 in, out, directorin, directorout</H3>


<p>Used for converting between the types for C/C++ and D when generating the code for the wrapper functions (on the C++ side).</p>

<p>The code from the <tt>in</tt> typemap is used to convert arguments to the C wrapper function to the type used in the wrapped code (<tt>cwtype</tt>->original C++ type), the <tt>out</tt> typemap is utilized to convert values from the wrapped code to wrapper function return types (original C++ type-><tt>cwtype</tt>).</p>

<p>The <tt>directorin</tt> typemap is used to convert parameters to the type used in the D director callback function, its return value is processed by <tt>directorout</tt> (see below).</p>


<H3><a name="D_din_dout_ddirectorin_ddirectorout"></a>36.3.4 din, dout, ddirectorin, ddirectorout</H3>


<p>Typemaps for code generation in D proxy and type wrapper classes.</p>

<p id="D_din">The <tt>din</tt> typemap is used for converting function parameter types from the type used in the proxy module or class to the type used in the D wrap module (the <a href="D.html#D_dinput"><tt>$dinput</tt></a> macro is replaced).</p>

<p id="D_dout">The <tt>dout</tt> typemap is used for converting function return values from the return type used in the wrap D module to the type returned by the proxy function. The <tt>$excode</tt> special variable in <tt>dout</tt> typemaps is replaced by the <tt>excode</tt> typemap attribute code if the method can throw any exceptions from unmanaged code, otherwise by nothing (the <a href="D.html#D_wcall"><tt>$wcall</tt> and <tt>$owner</tt></a> macros are replaced).</p>

<p id="D_ddirectorinout">The code from the <tt>ddirectorin</tt> and <tt>ddirectorout</tt> typemaps is used for conversion in director callback functions. Arguments are converted to the type used in the proxy class method they are calling by using the code from <tt>ddirectorin</tt>, the proxy class method return value is converted to the type the C++ code expects via the <tt>ddirectorout</tt> typemap (the <a href="D.html#D_dpcall"><tt>$dpcall</tt> and <tt>$winput</tt></a> macros are replaced).</p>

<p>The full chain of type conversions when a director callback is invoked looks like this:</p>

 <div class="diagram"><pre>      type CPPClass::method(type a)
        ↑                     ↓
   &lt;directorout&gt;         &lt;directorin&gt;
        ↑                     ↓
     cwtype methodCallback(cwtype a)    C++
 ::::::::::::::::::::::::::::::::::::::::::
     dwtype methodCallback(dwtype a)    D
        ↑                     ↓
  &lt;ddirectorout&gt;       &lt;ddirectorin&gt;
        ↑                     ↓
      dptype DClass.method(dptype a)</pre></div>


<H3><a name="D_typecheck_typemaps"></a>36.3.5 typecheck typemaps</H3>


<p>Because, unlike many scripting languages supported by SWIG, D does not need any dynamic dispatch helper to access an overloaded function, the purpose of these is merely to issue a warning for overloaded C++ functions that cannot be overloaded in D (as more than one C++ type maps to a single D type).</p>


<H3><a name="D_code_injection_typemaps"></a>36.3.6 Code injection typemaps</H3>


<p>These typemaps are used for generating the skeleton of proxy classes for C++ types.</p>

<p>By overriding <tt>dbase</tt>, <tt>dinterfaces</tt> or <tt>dinterfaces_derived</tt>, the inheritance chain of the generated proxy class for a type can be modified. <tt>dclassmodifiers</tt> allows you to add any custom modifiers around the class keyword.</p>

<p>Using <tt>dcode</tt> and <tt>dimports</tt>, you can specify additional D code which will be emitted into the class body respectively the imports section of the D module the class is written to.</p>

<p id="D_class_code_typemaps"><tt>dconstructor</tt>, <tt>ddestructor</tt>, <tt>ddispose</tt> and <tt>ddispose_derived</tt> are used to generate the class constructor, destructor and <tt>dispose()</tt> method, respectively. The auxiliary code for handling the pointer to the C++ object is stored in <tt>dbody</tt> and <tt>dbody_derived</tt>. You can override them for specific types.</p>


<H3><a name="D_special_variables"></a>36.3.7 Special variable macros</H3>


<p>The standard SWIG special variables are available for use within typemaps as described in the <a href="Typemaps.html#Typemaps">Typemaps documentation</a>, for example <tt>$1</tt>, <tt>$input</tt>, <tt>$result</tt> etc.</p>

<p>When generating D wrappers, a few additional macros are available:</p>
<dl>
  <dt><tt>$dclassname</tt> (C#: <tt>$csclassname</tt>)</dt>
  <dd>
    <p>This special variable works similar to <a href="Typemaps.html#Typemaps_special_variables"><tt>$n_type</tt></a> in that it returns the name of a type – it expands to the D proxy class name of the type being wrapped. If the type does not have an associated proxy class, it expands to the type wrapper class name, for example, <tt>SWIGTYPE_p_p_SomeCppClass</tt> is generated when wrapping <tt>SomeCppClass **</tt>.</p>
    <p>There are two other variants available, <tt>$&amp;dclassname</tt> and <tt>$*dclassname</tt>. The former adds a level of indirection, while the latter removes one. For instance, when wrapping <tt>Foo **</tt>, <tt>$*dclassname</tt> would be replaced by the proxy class name corresponding to <tt>Foo *</tt>.</p>
  </dd>

  <dt><tt>$null</tt></dt>
  <dd><p>In code inserted into the generated C/C++ wrapper functions, this variable is replaced by either <tt>0</tt> or nothing at all, depending on whether the function has a return value or not. It can be used to bail out early e.g. in case of errors (<tt>return $null;</tt>).</p></dd>

  <dt id="D_dinput"><tt>$dinput</tt> (C#: <tt>$csinput</tt>)</dt>
  <dd>
    <p>This variable is used in <tt><a href="D.html#D_din">din</a></tt> typemaps and is replaced by the expression which is to be passed to C/C++.</p>
    <p>For example, this input</p>
    <div class="code"><pre>
%typemap(din) SomeClass * "SomeClass.getCPointer($dinput)"

%inline %{
  class SomeClass {};
  void foo(SomeClass *arg);
%}</pre></div>
    <p>leads to the following D proxy code being generated:</p>
<div class="targetlang"><pre>
void foo(SomeClass arg) {
  example_wrap.foo(SomeClass.getCPointer(arg));
}</pre></div></dd>

  <dt id="D_wcall"><tt>$wcall</tt> and <tt>$owner</tt> (C#: <tt>$imcall</tt>)</dt>
  <dd>
    <p>These variables are used in <tt><a href="D.html#D_dout">dout</a></tt> typemaps. <tt>$wcall</tt> contains the call to the wrapper layer which provides the value to be used, and <tt>$owner</tt> signals if the caller is responsible for managing the object lifetime (that is, if the called method is a constructor or has been marked via <tt>%newobject</tt>).</p>
    <p>Consider the following example:</p>
<div class="code"><pre>
%typemap(dout) SomeClass * {
  return new SomeClass($wcall, $owner);
}

%inline %{
  class SomeClass;
  SomeClass *foo();

  %newobject bar();
  SomeClass *bar();
%}</pre></div>
   <p>The code generated for <tt>foo()</tt> and <tt>bar()</tt> looks like this:</p>
<div class="targetlang"><pre>
SomeClass foo() {
  return new SomeClass(example_wrap.foo(), false);
}

SomeClass bar() {
  return new SomeClass(example_wrap.bar(), true);
}
</pre></div>
  </dd>

  <dt><tt>$dpcall</tt> and <tt>$winput</tt> (C#: <tt>$cscall</tt>, <tt>$iminput</tt>)</dt>
  <dd id="D_dpcall"><p>These variables are used in the director-specific typemaps <a href="D.html#D_ddirectorinout"><tt>ddirectorin</tt></a> and <a href="D.html#D_ddirectorinout"><tt>ddirectorout</tt></a>. They are more or less the reverse of the <tt>$wcall</tt> and <tt>$dinput</tt> macros: <tt>$dpcall</tt> contains the invocation of the D proxy method of which the return value is to be passed back to C++, <tt>$winput</tt> contains the parameter value from C++.</p></dd>

  <dt><tt>$excode</tt></dt>
  <dd><p>This variable is used in <tt>dout</tt> and <tt>dconstructor</tt> typemaps and is filled with the contents of the <tt>excode</tt> typemap attribute if an exception could be thrown from the C++ side. See the <a href="CSharp.html#CSharp_exceptions">C# documentation</a> for details.</p></dd>

  <dt><tt>$dbaseclass</tt></dt>
  <dd><p>Currently for internal use only, it contains the D name of the C++ base class (if any) inside proxy classes.</p></dd>

  <dt><tt>$directorconnect</tt></dt>
  <dd>
    <p>This macro is only valid inside the <tt><a href="D.html#D_class_code_typemaps">dconstructor</a></tt> typemap and contains the value of the <tt>dconstructor</tt> typemap attribute if the currently wrapped class has directors enabled.</p>
    <p>This is how the default <tt>dconstructor</tt> typemap looks like (you usually do not want to specify a custom one):</p>
<div class="code"><pre>
%typemap(dconstructor, excode=SWIGEXCODE,directorconnect="\n  swigDirectorConnect();") SWIGTYPE {
  this($wcall, true);$excode$directorconnect
}
</pre></div>
  </dd>

  <dt><tt>$import_type(SomeDType)</tt></dt>
  <dd>
    <p>This macro is used in the <tt>dimports</tt> typemap if a dependency on another D type generated by SWIG is added by a custom typemap.</p>
    <p>Consider the following code snippet:</p>
<div class="code"><pre>
%typemap(dinterfaces) SomeClass "AnInterface, AnotherInterface";
</pre></div>
    <p>This causes SWIG to add <tt>AnInterface</tt> and <tt>AnotherInterface</tt> to the base class list of <tt>SomeClass</tt>:</p>
<div class="targetlang"><pre>
class SomeClass : AnInterface, AnotherInterface {
  …
}
</pre></div>
    <p>For this to work, <tt>AnInterface</tt> and <tt>AnotherInterface</tt> have to be in scope. If SWIG is not in split proxy mode, this is already the case, but it it is, they have to be added to the import list via the <tt>dimports</tt> typemap. Additionally, the import statement depends on the package SWIG is configured to emit the modules to.</p>
    <p>The <tt>$import_type</tt> macro helps you to elegantly solve this problem:</p>
<div class="code"><pre>
%typemap(dimports) RemoteMpe %{
$import_type(AnInterface)
$import_type(AnotherInterface)
%}
</pre></div>
    <p>If SWIG is in split proxy mode, it expands to an <tt>import</tt> statement for the specified type, to nothing if not.</p>
  </dd>

  <dt><tt>$module</tt></dt>
  <dd><p>Expands to the name of the main proxy D module.</p></dd>

  <dt><tt>$wrapdmodule</tt></dt>
  <dd><p>Contains the fully qualified name of the wrap D module.</p></dd>
</dl>


<H2><a name="D_features"></a>36.4 Features</H2>


<H2><a name="D_pragmas"></a>36.5 Pragmas</H2>


<H2><a name="D_exceptions"></a>36.6 D Exceptions</H2>


<p>Out of the box, C++ exceptions are fundamentally incompatible to their equivalent in the D world and cannot simply be propagated to a calling D method. There is, however, an easy way to solve this problem: Just catch the exception in the C/C++ wrapper layer, pass the contents to D, and make the wrapper code rethrow the exception in the D world.</p>

<p>The implementation details of this are a bit crude, but the SWIG D module automatically takes care of this, as long as it is able to detect that an exception could potentially be thrown (e.g. because the C++ method has a <tt>throw()</tt> exception specification).</p>

<p>As this feature is implemented in exactly the same way it is for C#, please see the <a href="CSharp.html#CSharp_exceptions">C# documentation</a> for a more detailed explanation.</p>


<H2><a name="D_directors"></a>36.7 D Directors</H2>


<p>When the directors feature is activated, SWIG generates extra code on both the C++ and the D side to enable cross-language polymorphism. Essentially, this means that if you subclass a proxy class in D, C++ code can access any overridden virtual methods just as if you created a derived class in C++.</p>

<p>There is no D specific documentation yet, but the way the feature is implemented is very similar to how it is done in <a href="Java.html#Java_directors">Java</a> and <a href="CSharp.html#CSharp_directors">C#</a>.
</p>


<H2><a name="D_other_features"></a>36.8 Other features</H2>


<p>The <a href="SWIGPlus.html#SWIGPlus_nspace"><tt>nspace</tt></a> feature of SWIG is not yet supported for D – all class modules are written to the same package, regardless of which C++ namespace they are in.</p>



<H2><a name="D_typemap_examples"></a>36.9 D Typemap examples</H2>


<p>There are no D-specific typemap examples yet. However, with the above <a href="D.html#D_typemap_name_comparison">name comparison table</a>, you should be able to get an idea what can be done by looking at the <a href="CSharp.html#CSharp_typemap_examples">corresponding C# section</a>.</p>



<H2><a name="D_planned_features"></a>36.10 Work in progress and planned features</H2>


<p>There are a couple of features which are not implemented yet, but would be very useful and might be added in the near future:</p>

<ul>
  <li><em>Memory management:</em> Although the currently generated wrapper code works fine with regard to the GC for the test-suite, I would not be surprised if there are issues coming up in real-world multi-threaded usage.</li>
  <li><em>Static linking:</em> Currently, the C wrapper code is compiled into a dynamic library, out of which the symbol addresses are looked up at runtime by the D part. If statically linking the different languages into one binary was supported, a tool-chain capable of performing IPO at link time could inline the wrapping code, effectively reducing the overhead for simple calls to zero.</li>
  <li><em>C array handling:</em> Many data structures in some C/C++ libraries contain array containing of a pointer to the first element and the element count. Currently, one must manually writing wrapper code to be able to access these from D. It should be possible to add a set of SWIG macros to semi-automatically generate conversion code.</li>
</ul>


</body>
</html>

